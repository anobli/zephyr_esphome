<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c": {"id": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "filePath": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "content": "#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/kernel.h&gt;\n\n#define DT_DRV_COMPAT NABUCASA_ESPHOME\n#define ESPHOME_NODE  DT_PATH(esphome)\n\n#define DEFINE_ACTION_FUNCTION(node_id, prop)                                                      \\\n\textern void DT_STRING_UNQUOTED(node_id, prop)(const struct device *dev);                   \\\n\tstatic inline void prop(const struct device *dev)                                          \\\n\t{                                                                                          \\\n\t\tDT_STRING_UNQUOTED(node_id, prop)(dev);                                            \\\n\t}\n\n#define DT_DEFINE_ACTION_FUNCTION(node_id, prop)                                                   \\\n\tCOND_CODE_1(DT_NODE_HAS_PROP(node_id, prop), (DEFINE_ACTION_FUNCTION(node_id, prop)),      \\\n\t\t    (static inline void prop(const struct device *dev){}))\n\nDT_DEFINE_ACTION_FUNCTION(ESPHOME_NODE, on_boot);\nDT_DEFINE_ACTION_FUNCTION(ESPHOME_NODE, on_loop);\nDT_DEFINE_ACTION_FUNCTION(ESPHOME_NODE, on_shutdown);\n#include &lt;stdio.h&gt;\nint esphome_service(void *arg1, void *arg2, void *arg3)\n{\n\ton_boot(NULL);\n\twhile (1) {\n\t\ton_loop(NULL);\n\t\tk_sleep(K_MSEC(1000));\n\t};\n}\n\n#define ESPHOME_STACK_SIZE (4096)\n\nK_THREAD_DEFINE(esphome_tid, ESPHOME_STACK_SIZE, esphome_service, NULL, NULL, NULL,\n\t\t0 /* todo: set priority */, 0, 0);"}, "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel.h": {"id": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel.h", "filePath": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel.h", "content": "/*\n * Copyright (c) 2016, Wind River Systems, Inc.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file\n *\n * @brief Public kernel APIs.\n */\n\n#ifndef ZEPHYR_INCLUDE_KERNEL_H_\n#define ZEPHYR_INCLUDE_KERNEL_H_\n\n#if !defined(_ASMLANGUAGE)\n#include &lt;zephyr/kernel_includes.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;zephyr/toolchain.h&gt;\n#include &lt;zephyr/tracing/tracing_macros.h&gt;\n#include &lt;zephyr/sys/mem_stats.h&gt;\n#include &lt;zephyr/sys/iterable_sections.h&gt;\n#include &lt;zephyr/sys/ring_buffer.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/*\n * Zephyr currently assumes the size of a couple standard types to simplify\n * print string formats. Let&#x27;s make sure this doesn&#x27;t change without notice.\n */\nBUILD_ASSERT(sizeof(int32_t) == sizeof(int));\nBUILD_ASSERT(sizeof(int64_t) == sizeof(long long));\nBUILD_ASSERT(sizeof(intptr_t) == sizeof(long));\n\n/**\n * @brief Kernel APIs\n * @defgroup kernel_apis Kernel APIs\n * @since 1.0\n * @version 1.0.0\n * @{\n * @}\n */\n\n#define K_ANY NULL\n\n#if (CONFIG_NUM_COOP_PRIORITIES + CONFIG_NUM_PREEMPT_PRIORITIES) == 0\n#error Zero available thread priorities defined!\n#endif\n\n#define K_PRIO_COOP(x) (-(CONFIG_NUM_COOP_PRIORITIES - (x)))\n#define K_PRIO_PREEMPT(x) (x)\n\n#define K_HIGHEST_THREAD_PRIO (-CONFIG_NUM_COOP_PRIORITIES)\n#define K_LOWEST_THREAD_PRIO CONFIG_NUM_PREEMPT_PRIORITIES\n#define K_IDLE_PRIO K_LOWEST_THREAD_PRIO\n#define K_HIGHEST_APPLICATION_THREAD_PRIO (K_HIGHEST_THREAD_PRIO)\n#define K_LOWEST_APPLICATION_THREAD_PRIO (K_LOWEST_THREAD_PRIO - 1)\n\n#ifdef CONFIG_POLL\n#define Z_POLL_EVENT_OBJ_INIT(obj) \\\n\t.poll_events = SYS_DLIST_STATIC_INIT(&amp;obj.poll_events),\n#define Z_DECL_POLL_EVENT sys_dlist_t poll_events;\n#else\n#define Z_POLL_EVENT_OBJ_INIT(obj)\n#define Z_DECL_POLL_EVENT\n#endif\n\nstruct k_thread;\nstruct k_mutex;\nstruct k_sem;\nstruct k_msgq;\nstruct k_mbox;\nstruct k_pipe;\nstruct k_queue;\nstruct k_fifo;\nstruct k_lifo;\nstruct k_stack;\nstruct k_mem_slab;\nstruct k_timer;\nstruct k_poll_event;\nstruct k_poll_signal;\nstruct k_mem_domain;\nstruct k_mem_partition;\nstruct k_futex;\nstruct k_event;\n\nenum execution_context_types {\n\tK_ISR = 0,\n\tK_COOP_THREAD,\n\tK_PREEMPT_THREAD,\n};\n\n/* private, used by k_poll and k_work_poll */\nstruct k_work_poll;\ntypedef int (*_poller_cb_t)(struct k_poll_event *event, uint32_t state);\n\n/**\n * @addtogroup thread_apis\n * @{\n */\n\ntypedef void (*k_thread_user_cb_t)(const struct k_thread *thread,\n\t\t\t\t   void *user_data);\n\n/**\n * @brief Iterate over all the threads in the system.\n *\n * This routine iterates over all the threads in the system and\n * calls the user_cb function for each thread.\n *\n * @param user_cb Pointer to the user callback function.\n * @param user_data Pointer to user data.\n *\n * @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function\n * to be effective.\n * @note This API uses @ref k_spin_lock to protect the _kernel.threads\n * list which means creation of new threads and terminations of existing\n * threads are blocked until this API returns.\n */\nvoid k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data);\n\n/**\n * @brief Iterate over all the threads in running on specified cpu.\n *\n * This function is does otherwise the same thing as k_thread_foreach(),\n * but it only loops through the threads running on specified cpu only.\n * If CONFIG_SMP is not defined the implementation this is the same as\n * k_thread_foreach(), with an assert cpu == 0.\n *\n * @param cpu The filtered cpu number\n * @param user_cb Pointer to the user callback function.\n * @param user_data Pointer to user data.\n *\n * @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function\n * to be effective.\n * @note This API uses @ref k_spin_lock to protect the _kernel.threads\n * list which means creation of new threads and terminations of existing\n * threads are blocked until this API returns.\n */\n#ifdef CONFIG_SMP\nvoid k_thread_foreach_filter_by_cpu(unsigned int cpu,\n\t\t\t\t    k_thread_user_cb_t user_cb, void *user_data);\n#else\nstatic inline\nvoid k_thread_foreach_filter_by_cpu(unsigned int cpu,\n\t\t\t\t    k_thread_user_cb_t user_cb, void *user_data)\n{\n\t__ASSERT(cpu == 0, &quot;cpu filter out of bounds&quot;);\n\tARG_UNUSED(cpu);\n\tk_thread_foreach(user_cb, user_data);\n}\n#endif\n\n/**\n * @brief Iterate over all the threads in the system without locking.\n *\n * This routine works exactly the same like @ref k_thread_foreach\n * but unlocks interrupts when user_cb is executed.\n *\n * @param user_cb Pointer to the user callback function.\n * @param user_data Pointer to user data.\n *\n * @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function\n * to be effective.\n * @note This API uses @ref k_spin_lock only when accessing the _kernel.threads\n * queue elements. It unlocks it during user callback function processing.\n * If a new task is created when this @c foreach function is in progress,\n * the added new task would not be included in the enumeration.\n * If a task is aborted during this enumeration, there would be a race here\n * and there is a possibility that this aborted task would be included in the\n * enumeration.\n * @note If the task is aborted and the memory occupied by its @c k_thread\n * structure is reused when this @c k_thread_foreach_unlocked is in progress\n * it might even lead to the system behave unstable.\n * This function may never return, as it would follow some @c next task\n * pointers treating given pointer as a pointer to the k_thread structure\n * while it is something different right now.\n * Do not reuse the memory that was occupied by k_thread structure of aborted\n * task if it was aborted after this function was called in any context.\n */\nvoid k_thread_foreach_unlocked(\n\tk_thread_user_cb_t user_cb, void *user_data);\n\n/**\n * @brief Iterate over the threads in running on current cpu without locking.\n *\n * This function does otherwise the same thing as\n * k_thread_foreach_unlocked(), but it only loops through the threads\n * running on specified cpu. If CONFIG_SMP is not defined the\n * implementation this is the same as k_thread_foreach_unlocked(), with an\n * assert requiring cpu == 0.\n *\n * @param cpu The filtered cpu number\n * @param user_cb Pointer to the user callback function.\n * @param user_data Pointer to user data.\n *\n * @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function\n * to be effective.\n * @note This API uses @ref k_spin_lock only when accessing the _kernel.threads\n * queue elements. It unlocks it during user callback function processing.\n * If a new task is created when this @c foreach function is in progress,\n * the added new task would not be included in the enumeration.\n * If a task is aborted during this enumeration, there would be a race here\n * and there is a possibility that this aborted task would be included in the\n * enumeration.\n * @note If the task is aborted and the memory occupied by its @c k_thread\n * structure is reused when this @c k_thread_foreach_unlocked is in progress\n * it might even lead to the system behave unstable.\n * This function may never return, as it would follow some @c next task\n * pointers treating given pointer as a pointer to the k_thread structure\n * while it is something different right now.\n * Do not reuse the memory that was occupied by k_thread structure of aborted\n * task if it was aborted after this function was called in any context.\n */\n#ifdef CONFIG_SMP\nvoid k_thread_foreach_unlocked_filter_by_cpu(unsigned int cpu,\n\t\t\t\t\t     k_thread_user_cb_t user_cb, void *user_data);\n#else\nstatic inline\nvoid k_thread_foreach_unlocked_filter_by_cpu(unsigned int cpu,\n\t\t\t\t\t     k_thread_user_cb_t user_cb, void *user_data)\n{\n\t__ASSERT(cpu == 0, &quot;cpu filter out of bounds&quot;);\n\tARG_UNUSED(cpu);\n\tk_thread_foreach_unlocked(user_cb, user_data);\n}\n#endif\n\n/** @} */\n\n/**\n * @defgroup thread_apis Thread APIs\n * @ingroup kernel_apis\n * @{\n */\n\n#endif /* !_ASMLANGUAGE */\n\n\n/*\n * Thread user options. May be needed by assembly code. Common part uses low\n * bits, arch-specific use high bits.\n */\n\n/**\n * @brief system thread that must not abort\n * */\n#define K_ESSENTIAL (BIT(0))\n\n#define K_FP_IDX 1\n/**\n * @brief FPU registers are managed by context switch\n *\n * @details\n * This option indicates that the thread uses the CPU&#x27;s floating point\n * registers. This instructs the kernel to take additional steps to save\n * and restore the contents of these registers when scheduling the thread.\n * No effect if @kconfig{CONFIG_FPU_SHARING} is not enabled.\n */\n#define K_FP_REGS (BIT(K_FP_IDX))\n\n/**\n * @brief user mode thread\n *\n * This thread has dropped from supervisor mode to user mode and consequently\n * has additional restrictions\n */\n#define K_USER (BIT(2))\n\n/**\n * @brief Inherit Permissions\n *\n * @details\n * Indicates that the thread being created should inherit all kernel object\n * permissions from the thread that created it. No effect if\n * @kconfig{CONFIG_USERSPACE} is not enabled.\n */\n#define K_INHERIT_PERMS (BIT(3))\n\n/**\n * @brief Callback item state\n *\n * @details\n * This is a single bit of state reserved for &quot;callback manager&quot;\n * utilities (p4wq initially) who need to track operations invoked\n * from within a user-provided callback they have been invoked.\n * Effectively it serves as a tiny bit of zero-overhead TLS data.\n */\n#define K_CALLBACK_STATE (BIT(4))\n\n/**\n * @brief DSP registers are managed by context switch\n *\n * @details\n * This option indicates that the thread uses the CPU&#x27;s DSP registers.\n * This instructs the kernel to take additional steps to save and\n * restore the contents of these registers when scheduling the thread.\n * No effect if @kconfig{CONFIG_DSP_SHARING} is not enabled.\n */\n#define K_DSP_IDX 6\n#define K_DSP_REGS (BIT(K_DSP_IDX))\n\n/**\n * @brief AGU registers are managed by context switch\n *\n * @details\n * This option indicates that the thread uses the ARC processor&#x27;s XY\n * memory and DSP feature. Often used with @kconfig{CONFIG_ARC_AGU_SHARING}.\n * No effect if @kconfig{CONFIG_ARC_AGU_SHARING} is not enabled.\n */\n#define K_AGU_IDX 7\n#define K_AGU_REGS (BIT(K_AGU_IDX))\n\n/**\n * @brief FP and SSE registers are managed by context switch on x86\n *\n * @details\n * This option indicates that the thread uses the x86 CPU&#x27;s floating point\n * and SSE registers. This instructs the kernel to take additional steps to\n * save and restore the contents of these registers when scheduling\n * the thread. No effect if @kconfig{CONFIG_X86_SSE} is not enabled.\n */\n#define K_SSE_REGS (BIT(7))\n\n/* end - thread options */\n\n#if !defined(_ASMLANGUAGE)\n/**\n * @brief Dynamically allocate a thread stack.\n *\n * Relevant stack creation flags include:\n * - @ref K_USER allocate a userspace thread (requires `CONFIG_USERSPACE=y`)\n *\n * @param size Stack size in bytes.\n * @param flags Stack creation flags, or 0.\n *\n * @retval the allocated thread stack on success.\n * @retval NULL on failure.\n *\n * @see CONFIG_DYNAMIC_THREAD\n */\n__syscall k_thread_stack_t *k_thread_stack_alloc(size_t size, int flags);\n\n/**\n * @brief Free a dynamically allocated thread stack.\n *\n * @param stack Pointer to the thread stack.\n *\n * @retval 0 on success.\n * @retval -EBUSY if the thread stack is in use.\n * @retval -EINVAL if @p stack is invalid.\n * @retval -ENOSYS if dynamic thread stack allocation is disabled\n *\n * @see CONFIG_DYNAMIC_THREAD\n */\n__syscall int k_thread_stack_free(k_thread_stack_t *stack);\n\n/**\n * @brief Create a thread.\n *\n * This routine initializes a thread, then schedules it for execution.\n *\n * The new thread may be scheduled for immediate execution or a delayed start.\n * If the newly spawned thread does not have a delayed start the kernel\n * scheduler may preempt the current thread to allow the new thread to\n * execute.\n *\n * Thread options are architecture-specific, and can include K_ESSENTIAL,\n * K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating\n * them using &quot;|&quot; (the logical OR operator).\n *\n * Stack objects passed to this function must be originally defined with\n * either of these macros in order to be portable:\n *\n * - K_THREAD_STACK_DEFINE() - For stacks that may support either user or\n *   supervisor threads.\n * - K_KERNEL_STACK_DEFINE() - For stacks that may support supervisor\n *   threads only. These stacks use less memory if CONFIG_USERSPACE is\n *   enabled.\n *\n * The stack_size parameter has constraints. It must either be:\n *\n * - The original size value passed to K_THREAD_STACK_DEFINE() or\n *   K_KERNEL_STACK_DEFINE()\n * - The return value of K_THREAD_STACK_SIZEOF(stack) if the stack was\n *   defined with K_THREAD_STACK_DEFINE()\n * - The return value of K_KERNEL_STACK_SIZEOF(stack) if the stack was\n *   defined with K_KERNEL_STACK_DEFINE().\n *\n * Using other values, or sizeof(stack) may produce undefined behavior.\n *\n * @param new_thread Pointer to uninitialized struct k_thread\n * @param stack Pointer to the stack space.\n * @param stack_size Stack size in bytes.\n * @param entry Thread entry function.\n * @param p1 1st entry point parameter.\n * @param p2 2nd entry point parameter.\n * @param p3 3rd entry point parameter.\n * @param prio Thread priority.\n * @param options Thread options.\n * @param delay Scheduling delay, or K_NO_WAIT (for no delay).\n *\n * @return ID of new thread.\n *\n */\n__syscall k_tid_t k_thread_create(struct k_thread *new_thread,\n\t\t\t\t  k_thread_stack_t *stack,\n\t\t\t\t  size_t stack_size,\n\t\t\t\t  k_thread_entry_t entry,\n\t\t\t\t  void *p1, void *p2, void *p3,\n\t\t\t\t  int prio, uint32_t options, k_timeout_t delay);\n\n/**\n * @brief Drop a thread&#x27;s privileges permanently to user mode\n *\n * This allows a supervisor thread to be re-used as a user thread.\n * This function does not return, but control will transfer to the provided\n * entry point as if this was a new user thread.\n *\n * The implementation ensures that the stack buffer contents are erased.\n * Any thread-local storage will be reverted to a pristine state.\n *\n * Memory domain membership, resource pool assignment, kernel object\n * permissions, priority, and thread options are preserved.\n *\n * A common use of this function is to re-use the main thread as a user thread\n * once all supervisor mode-only tasks have been completed.\n *\n * @param entry Function to start executing from\n * @param p1 1st entry point parameter\n * @param p2 2nd entry point parameter\n * @param p3 3rd entry point parameter\n */\nFUNC_NORETURN void k_thread_user_mode_enter(k_thread_entry_t entry,\n\t\t\t\t\t\t   void *p1, void *p2,\n\t\t\t\t\t\t   void *p3);\n\n/**\n * @brief Grant a thread access to a set of kernel objects\n *\n * This is a convenience function. For the provided thread, grant access to\n * the remaining arguments, which must be pointers to kernel objects.\n *\n * The thread object must be initialized (i.e. running). The objects don&#x27;t\n * need to be.\n * Note that NULL shouldn&#x27;t be passed as an argument.\n *\n * @param thread Thread to grant access to objects\n * @param ... list of kernel object pointers\n */\n#define k_thread_access_grant(thread, ...) \\\n\tFOR_EACH_FIXED_ARG(k_object_access_grant, (;), (thread), __VA_ARGS__)\n\n/**\n * @brief Assign a resource memory pool to a thread\n *\n * By default, threads have no resource pool assigned unless their parent\n * thread has a resource pool, in which case it is inherited. Multiple\n * threads may be assigned to the same memory pool.\n *\n * Changing a thread&#x27;s resource pool will not migrate allocations from the\n * previous pool.\n *\n * @param thread Target thread to assign a memory pool for resource requests.\n * @param heap Heap object to use for resources,\n *             or NULL if the thread should no longer have a memory pool.\n */\nstatic inline void k_thread_heap_assign(struct k_thread *thread,\n\t\t\t\t\tstruct k_heap *heap)\n{\n\tthread-&gt;resource_pool = heap;\n}\n\n#if defined(CONFIG_INIT_STACKS) &amp;&amp; defined(CONFIG_THREAD_STACK_INFO)\n/**\n * @brief Obtain stack usage information for the specified thread\n *\n * User threads will need to have permission on the target thread object.\n *\n * Some hardware may prevent inspection of a stack buffer currently in use.\n * If this API is called from supervisor mode, on the currently running thread,\n * on a platform which selects @kconfig{CONFIG_NO_UNUSED_STACK_INSPECTION}, an\n * error will be generated.\n *\n * @param thread Thread to inspect stack information\n * @param unused_ptr Output parameter, filled in with the unused stack space\n *\tof the target thread in bytes.\n * @return 0 on success\n * @return -EBADF Bad thread object (user mode only)\n * @return -EPERM No permissions on thread object (user mode only)\n * #return -ENOTSUP Forbidden by hardware policy\n * @return -EINVAL Thread is uninitialized or exited (user mode only)\n * @return -EFAULT Bad memory address for unused_ptr (user mode only)\n */\n__syscall int k_thread_stack_space_get(const struct k_thread *thread,\n\t\t\t\t       size_t *unused_ptr);\n#endif\n\n#if (K_HEAP_MEM_POOL_SIZE &gt; 0)\n/**\n * @brief Assign the system heap as a thread&#x27;s resource pool\n *\n * Similar to k_thread_heap_assign(), but the thread will use\n * the kernel heap to draw memory.\n *\n * Use with caution, as a malicious thread could perform DoS attacks on the\n * kernel heap.\n *\n * @param thread Target thread to assign the system heap for resource requests\n *\n */\nvoid k_thread_system_pool_assign(struct k_thread *thread);\n#endif /* (K_HEAP_MEM_POOL_SIZE &gt; 0) */\n\n/**\n * @brief Sleep until a thread exits\n *\n * The caller will be put to sleep until the target thread exits, either due\n * to being aborted, self-exiting, or taking a fatal error. This API returns\n * immediately if the thread isn&#x27;t running.\n *\n * This API may only be called from ISRs with a K_NO_WAIT timeout,\n * where it can be useful as a predicate to detect when a thread has\n * aborted.\n *\n * @param thread Thread to wait to exit\n * @param timeout upper bound time to wait for the thread to exit.\n * @retval 0 success, target thread has exited or wasn&#x27;t running\n * @retval -EBUSY returned without waiting\n * @retval -EAGAIN waiting period timed out\n * @retval -EDEADLK target thread is joining on the caller, or target thread\n *                  is the caller\n */\n__syscall int k_thread_join(struct k_thread *thread, k_timeout_t timeout);\n\n/**\n * @brief Put the current thread to sleep.\n *\n * This routine puts the current thread to sleep for @a duration,\n * specified as a k_timeout_t object.\n *\n * @param timeout Desired duration of sleep.\n *\n * @return Zero if the requested time has elapsed or if the thread was woken up\n * by the \\ref k_wakeup call, the time left to sleep rounded up to the nearest\n * millisecond.\n */\n__syscall int32_t k_sleep(k_timeout_t timeout);\n\n/**\n * @brief Put the current thread to sleep.\n *\n * This routine puts the current thread to sleep for @a duration milliseconds.\n *\n * @param ms Number of milliseconds to sleep.\n *\n * @return Zero if the requested time has elapsed or if the thread was woken up\n * by the \\ref k_wakeup call, the time left to sleep rounded up to the nearest\n * millisecond.\n */\nstatic inline int32_t k_msleep(int32_t ms)\n{\n\treturn k_sleep(Z_TIMEOUT_MS(ms));\n}\n\n/**\n * @brief Put the current thread to sleep with microsecond resolution.\n *\n * This function is unlikely to work as expected without kernel tuning.\n * In particular, because the lower bound on the duration of a sleep is\n * the duration of a tick, @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} must be\n * adjusted to achieve the resolution desired. The implications of doing\n * this must be understood before attempting to use k_usleep(). Use with\n * caution.\n *\n * @param us Number of microseconds to sleep.\n *\n * @return Zero if the requested time has elapsed or if the thread was woken up\n * by the \\ref k_wakeup call, the time left to sleep rounded up to the nearest\n * microsecond.\n */\n__syscall int32_t k_usleep(int32_t us);\n\n/**\n * @brief Cause the current thread to busy wait.\n *\n * This routine causes the current thread to execute a &quot;do nothing&quot; loop for\n * @a usec_to_wait microseconds.\n *\n * @note The clock used for the microsecond-resolution delay here may\n * be skewed relative to the clock used for system timeouts like\n * k_sleep().  For example k_busy_wait(1000) may take slightly more or\n * less time than k_sleep(K_MSEC(1)), with the offset dependent on\n * clock tolerances.\n *\n * @note In case when @kconfig{CONFIG_SYSTEM_CLOCK_SLOPPY_IDLE} and\n * @kconfig{CONFIG_PM} options are enabled, this function may not work.\n * The timer/clock used for delay processing may be disabled/inactive.\n */\n__syscall void k_busy_wait(uint32_t usec_to_wait);\n\n/**\n * @brief Check whether it is possible to yield in the current context.\n *\n * This routine checks whether the kernel is in a state where it is possible to\n * yield or call blocking API&#x27;s. It should be used by code that needs to yield\n * to perform correctly, but can feasibly be called from contexts where that\n * is not possible. For example in the PRE_KERNEL initialization step, or when\n * being run from the idle thread.\n *\n * @return True if it is possible to yield in the current context, false otherwise.\n */\nbool k_can_yield(void);\n\n/**\n * @brief Yield the current thread.\n *\n * This routine causes the current thread to yield execution to another\n * thread of the same or higher priority. If there are no other ready threads\n * of the same or higher priority, the routine returns immediately.\n */\n__syscall void k_yield(void);\n\n/**\n * @brief Wake up a sleeping thread.\n *\n * This routine prematurely wakes up @a thread from sleeping.\n *\n * If @a thread is not currently sleeping, the routine has no effect.\n *\n * @param thread ID of thread to wake.\n */\n__syscall void k_wakeup(k_tid_t thread);\n\n/**\n * @brief Query thread ID of the current thread.\n *\n * This unconditionally queries the kernel via a system call.\n *\n * @note Use k_current_get() unless absolutely sure this is necessary.\n *       This should only be used directly where the thread local\n *       variable cannot be used or may contain invalid values\n *       if thread local storage (TLS) is enabled. If TLS is not\n *       enabled, this is the same as k_current_get().\n *\n * @return ID of current thread.\n */\n__attribute_const__\n__syscall k_tid_t k_sched_current_thread_query(void);\n\n/**\n * @brief Get thread ID of the current thread.\n *\n * @return ID of current thread.\n *\n */\n__attribute_const__\nstatic inline k_tid_t k_current_get(void)\n{\n#ifdef CONFIG_CURRENT_THREAD_USE_TLS\n\n\t/* Thread-local cache of current thread ID, set in z_thread_entry() */\n\textern Z_THREAD_LOCAL k_tid_t z_tls_current;\n\n\treturn z_tls_current;\n#else\n\treturn k_sched_current_thread_query();\n#endif\n}\n\n/**\n * @brief Abort a thread.\n *\n * This routine permanently stops execution of @a thread. The thread is taken\n * off all kernel queues it is part of (i.e. the ready queue, the timeout\n * queue, or a kernel object wait queue). However, any kernel resources the\n * thread might currently own (such as mutexes or memory blocks) are not\n * released. It is the responsibility of the caller of this routine to ensure\n * all necessary cleanup is performed.\n *\n * After k_thread_abort() returns, the thread is guaranteed not to be\n * running or to become runnable anywhere on the system.  Normally\n * this is done via blocking the caller (in the same manner as\n * k_thread_join()), but in interrupt context on SMP systems the\n * implementation is required to spin for threads that are running on\n * other CPUs.\n *\n * @param thread ID of thread to abort.\n */\n__syscall void k_thread_abort(k_tid_t thread);\n\nk_ticks_t z_timeout_expires(const struct _timeout *timeout);\nk_ticks_t z_timeout_remaining(const struct _timeout *timeout);\n\n#ifdef CONFIG_SYS_CLOCK_EXISTS\n\n/**\n * @brief Get time when a thread wakes up, in system ticks\n *\n * This routine computes the system uptime when a waiting thread next\n * executes, in units of system ticks.  If the thread is not waiting,\n * it returns current system time.\n */\n__syscall k_ticks_t k_thread_timeout_expires_ticks(const struct k_thread *thread);\n\nstatic inline k_ticks_t z_impl_k_thread_timeout_expires_ticks(\n\t\t\t\t\t\tconst struct k_thread *thread)\n{\n\treturn z_timeout_expires(&amp;thread-&gt;base.timeout);\n}\n\n/**\n * @brief Get time remaining before a thread wakes up, in system ticks\n *\n * This routine computes the time remaining before a waiting thread\n * next executes, in units of system ticks.  If the thread is not\n * waiting, it returns zero.\n */\n__syscall k_ticks_t k_thread_timeout_remaining_ticks(const struct k_thread *thread);\n\nstatic inline k_ticks_t z_impl_k_thread_timeout_remaining_ticks(\n\t\t\t\t\t\tconst struct k_thread *thread)\n{\n\treturn z_timeout_remaining(&amp;thread-&gt;base.timeout);\n}\n\n#endif /* CONFIG_SYS_CLOCK_EXISTS */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\nstruct _static_thread_data {\n\tstruct k_thread *init_thread;\n\tk_thread_stack_t *init_stack;\n\tunsigned int init_stack_size;\n\tk_thread_entry_t init_entry;\n\tvoid *init_p1;\n\tvoid *init_p2;\n\tvoid *init_p3;\n\tint init_prio;\n\tuint32_t init_options;\n\tconst char *init_name;\n#ifdef CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME\n\tint32_t init_delay_ms;\n#else\n\tk_timeout_t init_delay;\n#endif\n};\n\n#ifdef CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME\n#define Z_THREAD_INIT_DELAY_INITIALIZER(ms) .init_delay_ms = (ms)\n#define Z_THREAD_INIT_DELAY(thread) SYS_TIMEOUT_MS((thread)-&gt;init_delay_ms)\n#else\n#define Z_THREAD_INIT_DELAY_INITIALIZER(ms) .init_delay = SYS_TIMEOUT_MS_INIT(ms)\n#define Z_THREAD_INIT_DELAY(thread) (thread)-&gt;init_delay\n#endif\n\n#define Z_THREAD_INITIALIZER(thread, stack, stack_size,           \\\n\t\t\t    entry, p1, p2, p3,                   \\\n\t\t\t    prio, options, delay, tname)         \\\n\t{                                                        \\\n\t.init_thread = (thread),\t\t\t\t \\\n\t.init_stack = (stack),\t\t\t\t\t \\\n\t.init_stack_size = (stack_size),                         \\\n\t.init_entry = (k_thread_entry_t)entry,\t\t\t \\\n\t.init_p1 = (void *)p1,                                   \\\n\t.init_p2 = (void *)p2,                                   \\\n\t.init_p3 = (void *)p3,                                   \\\n\t.init_prio = (prio),                                     \\\n\t.init_options = (options),                               \\\n\t.init_name = STRINGIFY(tname),                           \\\n\tZ_THREAD_INIT_DELAY_INITIALIZER(delay)\t\t\t \\\n\t}\n\n/*\n * Refer to K_THREAD_DEFINE() and K_KERNEL_THREAD_DEFINE() for\n * information on arguments.\n */\n#define Z_THREAD_COMMON_DEFINE(name, stack_size,\t\t\t\\\n\t\t\t       entry, p1, p2, p3,\t\t\t\\\n\t\t\t       prio, options, delay)\t\t\t\\\n\tstruct k_thread _k_thread_obj_##name;\t\t\t\t\\\n\tSTRUCT_SECTION_ITERABLE(_static_thread_data,\t\t\t\\\n\t\t\t\t_k_thread_data_##name) =\t\t\\\n\t\tZ_THREAD_INITIALIZER(&amp;_k_thread_obj_##name,\t\t\\\n\t\t\t\t     _k_thread_stack_##name, stack_size,\\\n\t\t\t\t     entry, p1, p2, p3, prio, options,\t\\\n\t\t\t\t     delay, name);\t\t\t\\\n\tconst k_tid_t name = (k_tid_t)&amp;_k_thread_obj_##name\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @brief Statically define and initialize a thread.\n *\n * The thread may be scheduled for immediate execution or a delayed start.\n *\n * Thread options are architecture-specific, and can include K_ESSENTIAL,\n * K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating\n * them using &quot;|&quot; (the logical OR operator).\n *\n * The ID of the thread can be accessed using:\n *\n * @code extern const k_tid_t &lt;name&gt;; @endcode\n *\n * @param name Name of the thread.\n * @param stack_size Stack size in bytes.\n * @param entry Thread entry function.\n * @param p1 1st entry point parameter.\n * @param p2 2nd entry point parameter.\n * @param p3 3rd entry point parameter.\n * @param prio Thread priority.\n * @param options Thread options.\n * @param delay Scheduling delay (in milliseconds), zero for no delay.\n *\n * @note Static threads with zero delay should not normally have\n * MetaIRQ priority levels.  This can preempt the system\n * initialization handling (depending on the priority of the main\n * thread) and cause surprising ordering side effects.  It will not\n * affect anything in the OS per se, but consider it bad practice.\n * Use a SYS_INIT() callback if you need to run code before entrance\n * to the application main().\n */\n#define K_THREAD_DEFINE(name, stack_size,                                \\\n\t\t\tentry, p1, p2, p3,                               \\\n\t\t\tprio, options, delay)                            \\\n\tK_THREAD_STACK_DEFINE(_k_thread_stack_##name, stack_size);\t \\\n\tZ_THREAD_COMMON_DEFINE(name, stack_size, entry, p1, p2, p3,\t \\\n\t\t\t       prio, options, delay)\n\n/**\n * @brief Statically define and initialize a thread intended to run only in kernel mode.\n *\n * The thread may be scheduled for immediate execution or a delayed start.\n *\n * Thread options are architecture-specific, and can include K_ESSENTIAL,\n * K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating\n * them using &quot;|&quot; (the logical OR operator).\n *\n * The ID of the thread can be accessed using:\n *\n * @code extern const k_tid_t &lt;name&gt;; @endcode\n *\n * @note Threads defined by this can only run in kernel mode, and cannot be\n *       transformed into user thread via k_thread_user_mode_enter().\n *\n * @warning Depending on the architecture, the stack size (@p stack_size)\n *          may need to be multiples of CONFIG_MMU_PAGE_SIZE (if MMU)\n *          or in power-of-two size (if MPU).\n *\n * @param name Name of the thread.\n * @param stack_size Stack size in bytes.\n * @param entry Thread entry function.\n * @param p1 1st entry point parameter.\n * @param p2 2nd entry point parameter.\n * @param p3 3rd entry point parameter.\n * @param prio Thread priority.\n * @param options Thread options.\n * @param delay Scheduling delay (in milliseconds), zero for no delay.\n */\n#define K_KERNEL_THREAD_DEFINE(name, stack_size,\t\t\t\\\n\t\t\t       entry, p1, p2, p3,\t\t\t\\\n\t\t\t       prio, options, delay)\t\t\t\\\n\tK_KERNEL_STACK_DEFINE(_k_thread_stack_##name, stack_size);\t\\\n\tZ_THREAD_COMMON_DEFINE(name, stack_size, entry, p1, p2, p3,\t\\\n\t\t\t       prio, options, delay)\n\n/**\n * @brief Get a thread&#x27;s priority.\n *\n * This routine gets the priority of @a thread.\n *\n * @param thread ID of thread whose priority is needed.\n *\n * @return Priority of @a thread.\n */\n__syscall int k_thread_priority_get(k_tid_t thread);\n\n/**\n * @brief Set a thread&#x27;s priority.\n *\n * This routine immediately changes the priority of @a thread.\n *\n * Rescheduling can occur immediately depending on the priority @a thread is\n * set to:\n *\n * - If its priority is raised above the priority of a currently scheduled\n * preemptible thread, @a thread will be scheduled in.\n *\n * - If the caller lowers the priority of a currently scheduled preemptible\n * thread below that of other threads in the system, the thread of the highest\n * priority will be scheduled in.\n *\n * Priority can be assigned in the range of -CONFIG_NUM_COOP_PRIORITIES to\n * CONFIG_NUM_PREEMPT_PRIORITIES-1, where -CONFIG_NUM_COOP_PRIORITIES is the\n * highest priority.\n *\n * @param thread ID of thread whose priority is to be set.\n * @param prio New priority.\n *\n * @warning Changing the priority of a thread currently involved in mutex\n * priority inheritance may result in undefined behavior.\n */\n__syscall void k_thread_priority_set(k_tid_t thread, int prio);\n\n\n#ifdef CONFIG_SCHED_DEADLINE\n/**\n * @brief Set deadline expiration time for scheduler\n *\n * This sets the &quot;deadline&quot; expiration as a time delta from the\n * current time, in the same units used by k_cycle_get_32().  The\n * scheduler (when deadline scheduling is enabled) will choose the\n * next expiring thread when selecting between threads at the same\n * static priority.  Threads at different priorities will be scheduled\n * according to their static priority.\n *\n * @note Deadlines are stored internally using 32 bit unsigned\n * integers.  The number of cycles between the &quot;first&quot; deadline in the\n * scheduler queue and the &quot;last&quot; deadline must be less than 2^31 (i.e\n * a signed non-negative quantity).  Failure to adhere to this rule\n * may result in scheduled threads running in an incorrect deadline\n * order.\n *\n * @note Despite the API naming, the scheduler makes no guarantees\n * the thread WILL be scheduled within that deadline, nor does it take\n * extra metadata (like e.g. the &quot;runtime&quot; and &quot;period&quot; parameters in\n * Linux sched_setattr()) that allows the kernel to validate the\n * scheduling for achievability.  Such features could be implemented\n * above this call, which is simply input to the priority selection\n * logic.\n *\n * @note You should enable @kconfig{CONFIG_SCHED_DEADLINE} in your project\n * configuration.\n *\n * @param thread A thread on which to set the deadline\n * @param deadline A time delta, in cycle units\n *\n */\n__syscall void k_thread_deadline_set(k_tid_t thread, int deadline);\n#endif\n\n/**\n * @brief Invoke the scheduler\n *\n * This routine invokes the scheduler to force a schedule point on the current\n * CPU. If invoked from within a thread, the scheduler will be invoked\n * immediately (provided interrupts were not locked when invoked). If invoked\n * from within an ISR, the scheduler will be invoked upon exiting the ISR.\n *\n * Invoking the scheduler allows the kernel to make an immediate determination\n * as to what the next thread to execute should be. Unlike yielding, this\n * routine is not guaranteed to switch to a thread of equal or higher priority\n * if any are available. For example, if the current thread is cooperative and\n * there is a still higher priority cooperative thread that is ready, then\n * yielding will switch to that higher priority thread whereas this routine\n * will not.\n *\n * Most applications will never use this routine.\n */\n__syscall void k_reschedule(void);\n\n#ifdef CONFIG_SCHED_CPU_MASK\n/**\n * @brief Sets all CPU enable masks to zero\n *\n * After this returns, the thread will no longer be schedulable on any\n * CPUs.  The thread must not be currently runnable.\n *\n * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project\n * configuration.\n *\n * @param thread Thread to operate upon\n * @return Zero on success, otherwise error code\n */\nint k_thread_cpu_mask_clear(k_tid_t thread);\n\n/**\n * @brief Sets all CPU enable masks to one\n *\n * After this returns, the thread will be schedulable on any CPU.  The\n * thread must not be currently runnable.\n *\n * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project\n * configuration.\n *\n * @param thread Thread to operate upon\n * @return Zero on success, otherwise error code\n */\nint k_thread_cpu_mask_enable_all(k_tid_t thread);\n\n/**\n * @brief Enable thread to run on specified CPU\n *\n * The thread must not be currently runnable.\n *\n * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project\n * configuration.\n *\n * @param thread Thread to operate upon\n * @param cpu CPU index\n * @return Zero on success, otherwise error code\n */\nint k_thread_cpu_mask_enable(k_tid_t thread, int cpu);\n\n/**\n * @brief Prevent thread to run on specified CPU\n *\n * The thread must not be currently runnable.\n *\n * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project\n * configuration.\n *\n * @param thread Thread to operate upon\n * @param cpu CPU index\n * @return Zero on success, otherwise error code\n */\nint k_thread_cpu_mask_disable(k_tid_t thread, int cpu);\n\n/**\n * @brief Pin a thread to a CPU\n *\n * Pin a thread to a CPU by first clearing the cpu mask and then enabling the\n * thread on the selected CPU.\n *\n * @param thread Thread to operate upon\n * @param cpu CPU index\n * @return Zero on success, otherwise error code\n */\nint k_thread_cpu_pin(k_tid_t thread, int cpu);\n#endif\n\n/**\n * @brief Suspend a thread.\n *\n * This routine prevents the kernel scheduler from making @a thread\n * the current thread. All other internal operations on @a thread are\n * still performed; for example, kernel objects it is waiting on are\n * still handed to it. Thread suspension does not impact any timeout\n * upon which the thread may be waiting (such as a timeout from a call\n * to k_sem_take() or k_sleep()). Thus if the timeout expires while the\n * thread is suspended, it is still suspended until k_thread_resume()\n * is called.\n *\n * When the target thread is active on another CPU, the caller will block until\n * the target thread is halted (suspended or aborted).  But if the caller is in\n * an interrupt context, it will spin waiting for that target thread active on\n * another CPU to halt.\n *\n * If @a thread is already suspended, the routine has no effect.\n *\n * @param thread ID of thread to suspend.\n */\n__syscall void k_thread_suspend(k_tid_t thread);\n\n/**\n * @brief Resume a suspended thread.\n *\n * This routine reverses the thread suspension from k_thread_suspend()\n * and allows the kernel scheduler to make @a thread the current thread\n * when it is next eligible for that role.\n *\n * If @a thread is not currently suspended, the routine has no effect.\n *\n * @param thread ID of thread to resume.\n */\n__syscall void k_thread_resume(k_tid_t thread);\n\n/**\n * @brief Start an inactive thread\n *\n * If a thread was created with K_FOREVER in the delay parameter, it will\n * not be added to the scheduling queue until this function is called\n * on it.\n *\n * @note This is a legacy API for compatibility.  Modern Zephyr\n * threads are initialized in the &quot;sleeping&quot; state and do not need\n * special handling for &quot;start&quot;.\n *\n * @param thread thread to start\n */\nstatic inline void k_thread_start(k_tid_t thread)\n{\n\tk_wakeup(thread);\n}\n\n/**\n * @brief Set time-slicing period and scope.\n *\n * This routine specifies how the scheduler will perform time slicing of\n * preemptible threads.\n *\n * To enable time slicing, @a slice must be non-zero. The scheduler\n * ensures that no thread runs for more than the specified time limit\n * before other threads of that priority are given a chance to execute.\n * Any thread whose priority is higher than @a prio is exempted, and may\n * execute as long as desired without being preempted due to time slicing.\n *\n * Time slicing only limits the maximum amount of time a thread may continuously\n * execute. Once the scheduler selects a thread for execution, there is no\n * minimum guaranteed time the thread will execute before threads of greater or\n * equal priority are scheduled.\n *\n * When the current thread is the only one of that priority eligible\n * for execution, this routine has no effect; the thread is immediately\n * rescheduled after the slice period expires.\n *\n * To disable timeslicing, set both @a slice and @a prio to zero.\n *\n * @param slice Maximum time slice length (in milliseconds).\n * @param prio Highest thread priority level eligible for time slicing.\n */\nvoid k_sched_time_slice_set(int32_t slice, int prio);\n\n/**\n * @brief Set thread time slice\n *\n * As for k_sched_time_slice_set, but (when\n * CONFIG_TIMESLICE_PER_THREAD=y) sets the timeslice for a specific\n * thread.  When non-zero, this timeslice will take precedence over\n * the global value.\n *\n * When such a thread&#x27;s timeslice expires, the configured callback\n * will be called before the thread is removed/re-added to the run\n * queue.  This callback will occur in interrupt context, and the\n * specified thread is guaranteed to have been preempted by the\n * currently-executing ISR.  Such a callback is free to, for example,\n * modify the thread priority or slice time for future execution,\n * suspend the thread, etc...\n *\n * @note Unlike the older API, the time slice parameter here is\n * specified in ticks, not milliseconds.  Ticks have always been the\n * internal unit, and not all platforms have integer conversions\n * between the two.\n *\n * @note Threads with a non-zero slice time set will be timesliced\n * always, even if they are higher priority than the maximum timeslice\n * priority set via k_sched_time_slice_set().\n *\n * @note The callback notification for slice expiration happens, as it\n * must, while the thread is still &quot;current&quot;, and thus it happens\n * before any registered timeouts at this tick.  This has the somewhat\n * confusing side effect that the tick time (c.f. k_uptime_get()) does\n * not yet reflect the expired ticks.  Applications wishing to make\n * fine-grained timing decisions within this callback should use the\n * cycle API, or derived facilities like k_thread_runtime_stats_get().\n *\n * @param th A valid, initialized thread\n * @param slice_ticks Maximum timeslice, in ticks\n * @param expired Callback function called on slice expiration\n * @param data Parameter for the expiration handler\n */\nvoid k_thread_time_slice_set(struct k_thread *th, int32_t slice_ticks,\n\t\t\t     k_thread_timeslice_fn_t expired, void *data);\n\n/** @} */\n\n/**\n * @addtogroup isr_apis\n * @{\n */\n\n/**\n * @brief Determine if code is running at interrupt level.\n *\n * This routine allows the caller to customize its actions, depending on\n * whether it is a thread or an ISR.\n *\n * @funcprops \\isr_ok\n *\n * @return false if invoked by a thread.\n * @return true if invoked by an ISR.\n */\nbool k_is_in_isr(void);\n\n/**\n * @brief Determine if code is running in a preemptible thread.\n *\n * This routine allows the caller to customize its actions, depending on\n * whether it can be preempted by another thread. The routine returns a &#x27;true&#x27;\n * value if all of the following conditions are met:\n *\n * - The code is running in a thread, not at ISR.\n * - The thread&#x27;s priority is in the preemptible range.\n * - The thread has not locked the scheduler.\n *\n * @funcprops \\isr_ok\n *\n * @return 0 if invoked by an ISR or by a cooperative thread.\n * @return Non-zero if invoked by a preemptible thread.\n */\n__syscall int k_is_preempt_thread(void);\n\n/**\n * @brief Test whether startup is in the before-main-task phase.\n *\n * This routine allows the caller to customize its actions, depending on\n * whether it being invoked before the kernel is fully active.\n *\n * @funcprops \\isr_ok\n *\n * @return true if invoked before post-kernel initialization\n * @return false if invoked during/after post-kernel initialization\n */\nstatic inline bool k_is_pre_kernel(void)\n{\n\textern bool z_sys_post_kernel; /* in init.c */\n\n\treturn !z_sys_post_kernel;\n}\n\n/**\n * @}\n */\n\n/**\n * @addtogroup thread_apis\n * @{\n */\n\n/**\n * @brief Lock the scheduler.\n *\n * This routine prevents the current thread from being preempted by another\n * thread by instructing the scheduler to treat it as a cooperative thread.\n * If the thread subsequently performs an operation that makes it unready,\n * it will be context switched out in the normal manner. When the thread\n * again becomes the current thread, its non-preemptible status is maintained.\n *\n * This routine can be called recursively.\n *\n * Owing to clever implementation details, scheduler locks are\n * extremely fast for non-userspace threads (just one byte\n * inc/decrement in the thread struct).\n *\n * @note This works by elevating the thread priority temporarily to a\n * cooperative priority, allowing cheap synchronization vs. other\n * preemptible or cooperative threads running on the current CPU.  It\n * does not prevent preemption or asynchrony of other types.  It does\n * not prevent threads from running on other CPUs when CONFIG_SMP=y.\n * It does not prevent interrupts from happening, nor does it prevent\n * threads with MetaIRQ priorities from preempting the current thread.\n * In general this is a historical API not well-suited to modern\n * applications, use with care.\n */\nvoid k_sched_lock(void);\n\n/**\n * @brief Unlock the scheduler.\n *\n * This routine reverses the effect of a previous call to k_sched_lock().\n * A thread must call the routine once for each time it called k_sched_lock()\n * before the thread becomes preemptible.\n */\nvoid k_sched_unlock(void);\n\n/**\n * @brief Set current thread&#x27;s custom data.\n *\n * This routine sets the custom data for the current thread to @ value.\n *\n * Custom data is not used by the kernel itself, and is freely available\n * for a thread to use as it sees fit. It can be used as a framework\n * upon which to build thread-local storage.\n *\n * @param value New custom data value.\n *\n */\n__syscall void k_thread_custom_data_set(void *value);\n\n/**\n * @brief Get current thread&#x27;s custom data.\n *\n * This routine returns the custom data for the current thread.\n *\n * @return Current custom data value.\n */\n__syscall void *k_thread_custom_data_get(void);\n\n/**\n * @brief Set current thread name\n *\n * Set the name of the thread to be used when @kconfig{CONFIG_THREAD_MONITOR}\n * is enabled for tracing and debugging.\n *\n * @param thread Thread to set name, or NULL to set the current thread\n * @param str Name string\n * @retval 0 on success\n * @retval -EFAULT Memory access error with supplied string\n * @retval -ENOSYS Thread name configuration option not enabled\n * @retval -EINVAL Thread name too long\n */\n__syscall int k_thread_name_set(k_tid_t thread, const char *str);\n\n/**\n * @brief Get thread name\n *\n * Get the name of a thread\n *\n * @param thread Thread ID\n * @retval Thread name, or NULL if configuration not enabled\n */\nconst char *k_thread_name_get(k_tid_t thread);\n\n/**\n * @brief Copy the thread name into a supplied buffer\n *\n * @param thread Thread to obtain name information\n * @param buf Destination buffer\n * @param size Destination buffer size\n * @retval -ENOSPC Destination buffer too small\n * @retval -EFAULT Memory access error\n * @retval -ENOSYS Thread name feature not enabled\n * @retval 0 Success\n */\n__syscall int k_thread_name_copy(k_tid_t thread, char *buf,\n\t\t\t\t size_t size);\n\n/**\n * @brief Get thread state string\n *\n * This routine generates a human friendly string containing the thread&#x27;s\n * state, and copies as much of it as possible into @a buf.\n *\n * @param thread_id Thread ID\n * @param buf Buffer into which to copy state strings\n * @param buf_size Size of the buffer\n *\n * @retval Pointer to @a buf if data was copied, else a pointer to &quot;&quot;.\n */\nconst char *k_thread_state_str(k_tid_t thread_id, char *buf, size_t buf_size);\n\n/**\n * @}\n */\n\n/**\n * @addtogroup clock_apis\n * @{\n */\n\n/**\n * @brief Generate null timeout delay.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * not to wait if the requested operation cannot be performed immediately.\n *\n * @return Timeout delay value.\n */\n#define K_NO_WAIT Z_TIMEOUT_NO_WAIT\n\n/**\n * @brief Generate timeout delay from nanoseconds.\n *\n * This macro generates a timeout delay that instructs a kernel API to\n * wait up to @a t nanoseconds to perform the requested operation.\n * Note that timer precision is limited to the tick rate, not the\n * requested value.\n *\n * @param t Duration in nanoseconds.\n *\n * @return Timeout delay value.\n */\n#define K_NSEC(t)     Z_TIMEOUT_NS(t)\n\n/**\n * @brief Generate timeout delay from microseconds.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * to wait up to @a t microseconds to perform the requested operation.\n * Note that timer precision is limited to the tick rate, not the\n * requested value.\n *\n * @param t Duration in microseconds.\n *\n * @return Timeout delay value.\n */\n#define K_USEC(t)     Z_TIMEOUT_US(t)\n\n/**\n * @brief Generate timeout delay from cycles.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * to wait up to @a t cycles to perform the requested operation.\n *\n * @param t Duration in cycles.\n *\n * @return Timeout delay value.\n */\n#define K_CYC(t)     Z_TIMEOUT_CYC(t)\n\n/**\n * @brief Generate timeout delay from system ticks.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * to wait up to @a t ticks to perform the requested operation.\n *\n * @param t Duration in system ticks.\n *\n * @return Timeout delay value.\n */\n#define K_TICKS(t)     Z_TIMEOUT_TICKS(t)\n\n/**\n * @brief Generate timeout delay from milliseconds.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * to wait up to @a ms milliseconds to perform the requested operation.\n *\n * @param ms Duration in milliseconds.\n *\n * @return Timeout delay value.\n */\n#define K_MSEC(ms)     Z_TIMEOUT_MS(ms)\n\n/**\n * @brief Generate timeout delay from seconds.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * to wait up to @a s seconds to perform the requested operation.\n *\n * @param s Duration in seconds.\n *\n * @return Timeout delay value.\n */\n#define K_SECONDS(s)   K_MSEC((s) * MSEC_PER_SEC)\n\n/**\n * @brief Generate timeout delay from minutes.\n\n * This macro generates a timeout delay that instructs a kernel API\n * to wait up to @a m minutes to perform the requested operation.\n *\n * @param m Duration in minutes.\n *\n * @return Timeout delay value.\n */\n#define K_MINUTES(m)   K_SECONDS((m) * 60)\n\n/**\n * @brief Generate timeout delay from hours.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * to wait up to @a h hours to perform the requested operation.\n *\n * @param h Duration in hours.\n *\n * @return Timeout delay value.\n */\n#define K_HOURS(h)     K_MINUTES((h) * 60)\n\n/**\n * @brief Generate infinite timeout delay.\n *\n * This macro generates a timeout delay that instructs a kernel API\n * to wait as long as necessary to perform the requested operation.\n *\n * @return Timeout delay value.\n */\n#define K_FOREVER Z_FOREVER\n\n#ifdef CONFIG_TIMEOUT_64BIT\n\n/**\n * @brief Generates an absolute/uptime timeout value from system ticks\n *\n * This macro generates a timeout delay that represents an expiration\n * at the absolute uptime value specified, in system ticks.  That is, the\n * timeout will expire immediately after the system uptime reaches the\n * specified tick count.\n *\n * @param t Tick uptime value\n * @return Timeout delay value\n */\n#define K_TIMEOUT_ABS_TICKS(t) \\\n\tZ_TIMEOUT_TICKS(Z_TICK_ABS((k_ticks_t)MAX(t, 0)))\n\n/**\n * @brief Generates an absolute/uptime timeout value from milliseconds\n *\n * This macro generates a timeout delay that represents an expiration\n * at the absolute uptime value specified, in milliseconds.  That is,\n * the timeout will expire immediately after the system uptime reaches\n * the specified tick count.\n *\n * @param t Millisecond uptime value\n * @return Timeout delay value\n */\n#define K_TIMEOUT_ABS_MS(t) K_TIMEOUT_ABS_TICKS(k_ms_to_ticks_ceil64(t))\n\n/**\n * @brief Generates an absolute/uptime timeout value from microseconds\n *\n * This macro generates a timeout delay that represents an expiration\n * at the absolute uptime value specified, in microseconds.  That is,\n * the timeout will expire immediately after the system uptime reaches\n * the specified time.  Note that timer precision is limited by the\n * system tick rate and not the requested timeout value.\n *\n * @param t Microsecond uptime value\n * @return Timeout delay value\n */\n#define K_TIMEOUT_ABS_US(t) K_TIMEOUT_ABS_TICKS(k_us_to_ticks_ceil64(t))\n\n/**\n * @brief Generates an absolute/uptime timeout value from nanoseconds\n *\n * This macro generates a timeout delay that represents an expiration\n * at the absolute uptime value specified, in nanoseconds.  That is,\n * the timeout will expire immediately after the system uptime reaches\n * the specified time.  Note that timer precision is limited by the\n * system tick rate and not the requested timeout value.\n *\n * @param t Nanosecond uptime value\n * @return Timeout delay value\n */\n#define K_TIMEOUT_ABS_NS(t) K_TIMEOUT_ABS_TICKS(k_ns_to_ticks_ceil64(t))\n\n/**\n * @brief Generates an absolute/uptime timeout value from system cycles\n *\n * This macro generates a timeout delay that represents an expiration\n * at the absolute uptime value specified, in cycles.  That is, the\n * timeout will expire immediately after the system uptime reaches the\n * specified time.  Note that timer precision is limited by the system\n * tick rate and not the requested timeout value.\n *\n * @param t Cycle uptime value\n * @return Timeout delay value\n */\n#define K_TIMEOUT_ABS_CYC(t) K_TIMEOUT_ABS_TICKS(k_cyc_to_ticks_ceil64(t))\n\n#endif\n\n/**\n * @}\n */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\nstruct k_timer {\n\t/*\n\t * _timeout structure must be first here if we want to use\n\t * dynamic timer allocation. timeout.node is used in the double-linked\n\t * list of free timers\n\t */\n\tstruct _timeout timeout;\n\n\t/* wait queue for the (single) thread waiting on this timer */\n\t_wait_q_t wait_q;\n\n\t/* runs in ISR context */\n\tvoid (*expiry_fn)(struct k_timer *timer);\n\n\t/* runs in the context of the thread that calls k_timer_stop() */\n\tvoid (*stop_fn)(struct k_timer *timer);\n\n\t/* timer period */\n\tk_timeout_t period;\n\n\t/* timer status */\n\tuint32_t status;\n\n\t/* user-specific data, also used to support legacy features */\n\tvoid *user_data;\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_timer)\n\n#ifdef CONFIG_OBJ_CORE_TIMER\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n#define Z_TIMER_INITIALIZER(obj, expiry, stop) \\\n\t{ \\\n\t.timeout = { \\\n\t\t.node = {},\\\n\t\t.fn = z_timer_expiration_handler, \\\n\t\t.dticks = 0, \\\n\t}, \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;obj.wait_q), \\\n\t.expiry_fn = expiry, \\\n\t.stop_fn = stop, \\\n\t.status = 0, \\\n\t.user_data = 0, \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup timer_apis Timer APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @typedef k_timer_expiry_t\n * @brief Timer expiry function type.\n *\n * A timer&#x27;s expiry function is executed by the system clock interrupt handler\n * each time the timer expires. The expiry function is optional, and is only\n * invoked if the timer has been initialized with one.\n *\n * @param timer     Address of timer.\n */\ntypedef void (*k_timer_expiry_t)(struct k_timer *timer);\n\n/**\n * @typedef k_timer_stop_t\n * @brief Timer stop function type.\n *\n * A timer&#x27;s stop function is executed if the timer is stopped prematurely.\n * The function runs in the context of call that stops the timer.  As\n * k_timer_stop() can be invoked from an ISR, the stop function must be\n * callable from interrupt context (isr-ok).\n *\n * The stop function is optional, and is only invoked if the timer has been\n * initialized with one.\n *\n * @param timer     Address of timer.\n */\ntypedef void (*k_timer_stop_t)(struct k_timer *timer);\n\n/**\n * @brief Statically define and initialize a timer.\n *\n * The timer can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_timer &lt;name&gt;; @endcode\n *\n * @param name Name of the timer variable.\n * @param expiry_fn Function to invoke each time the timer expires.\n * @param stop_fn   Function to invoke if the timer is stopped while running.\n */\n#define K_TIMER_DEFINE(name, expiry_fn, stop_fn) \\\n\tSTRUCT_SECTION_ITERABLE(k_timer, name) = \\\n\t\tZ_TIMER_INITIALIZER(name, expiry_fn, stop_fn)\n\n/**\n * @brief Initialize a timer.\n *\n * This routine initializes a timer, prior to its first use.\n *\n * @param timer     Address of timer.\n * @param expiry_fn Function to invoke each time the timer expires.\n * @param stop_fn   Function to invoke if the timer is stopped while running.\n */\nvoid k_timer_init(struct k_timer *timer,\n\t\t\t k_timer_expiry_t expiry_fn,\n\t\t\t k_timer_stop_t stop_fn);\n\n/**\n * @brief Start a timer.\n *\n * This routine starts a timer, and resets its status to zero. The timer\n * begins counting down using the specified duration and period values.\n *\n * Attempting to start a timer that is already running is permitted.\n * The timer&#x27;s status is reset to zero and the timer begins counting down\n * using the new duration and period values.\n *\n * @param timer     Address of timer.\n * @param duration  Initial timer duration.\n * @param period    Timer period.\n */\n__syscall void k_timer_start(struct k_timer *timer,\n\t\t\t     k_timeout_t duration, k_timeout_t period);\n\n/**\n * @brief Stop a timer.\n *\n * This routine stops a running timer prematurely. The timer&#x27;s stop function,\n * if one exists, is invoked by the caller.\n *\n * Attempting to stop a timer that is not running is permitted, but has no\n * effect on the timer.\n *\n * @note The stop handler has to be callable from ISRs if @a k_timer_stop is to\n * be called from ISRs.\n *\n * @funcprops \\isr_ok\n *\n * @param timer     Address of timer.\n */\n__syscall void k_timer_stop(struct k_timer *timer);\n\n/**\n * @brief Read timer status.\n *\n * This routine reads the timer&#x27;s status, which indicates the number of times\n * it has expired since its status was last read.\n *\n * Calling this routine resets the timer&#x27;s status to zero.\n *\n * @param timer     Address of timer.\n *\n * @return Timer status.\n */\n__syscall uint32_t k_timer_status_get(struct k_timer *timer);\n\n/**\n * @brief Synchronize thread to timer expiration.\n *\n * This routine blocks the calling thread until the timer&#x27;s status is non-zero\n * (indicating that it has expired at least once since it was last examined)\n * or the timer is stopped. If the timer status is already non-zero,\n * or the timer is already stopped, the caller continues without waiting.\n *\n * Calling this routine resets the timer&#x27;s status to zero.\n *\n * This routine must not be used by interrupt handlers, since they are not\n * allowed to block.\n *\n * @param timer     Address of timer.\n *\n * @return Timer status.\n */\n__syscall uint32_t k_timer_status_sync(struct k_timer *timer);\n\n#ifdef CONFIG_SYS_CLOCK_EXISTS\n\n/**\n * @brief Get next expiration time of a timer, in system ticks\n *\n * This routine returns the future system uptime reached at the next\n * time of expiration of the timer, in units of system ticks.  If the\n * timer is not running, current system time is returned.\n *\n * @param timer The timer object\n * @return Uptime of expiration, in ticks\n */\n__syscall k_ticks_t k_timer_expires_ticks(const struct k_timer *timer);\n\nstatic inline k_ticks_t z_impl_k_timer_expires_ticks(\n\t\t\t\t       const struct k_timer *timer)\n{\n\treturn z_timeout_expires(&amp;timer-&gt;timeout);\n}\n\n/**\n * @brief Get time remaining before a timer next expires, in system ticks\n *\n * This routine computes the time remaining before a running timer\n * next expires, in units of system ticks.  If the timer is not\n * running, it returns zero.\n *\n * @param timer The timer object\n * @return Remaining time until expiration, in ticks\n */\n__syscall k_ticks_t k_timer_remaining_ticks(const struct k_timer *timer);\n\nstatic inline k_ticks_t z_impl_k_timer_remaining_ticks(\n\t\t\t\t       const struct k_timer *timer)\n{\n\treturn z_timeout_remaining(&amp;timer-&gt;timeout);\n}\n\n/**\n * @brief Get time remaining before a timer next expires.\n *\n * This routine computes the (approximate) time remaining before a running\n * timer next expires. If the timer is not running, it returns zero.\n *\n * @param timer     Address of timer.\n *\n * @return Remaining time (in milliseconds).\n */\nstatic inline uint32_t k_timer_remaining_get(struct k_timer *timer)\n{\n\treturn k_ticks_to_ms_floor32(k_timer_remaining_ticks(timer));\n}\n\n#endif /* CONFIG_SYS_CLOCK_EXISTS */\n\n/**\n * @brief Associate user-specific data with a timer.\n *\n * This routine records the @a user_data with the @a timer, to be retrieved\n * later.\n *\n * It can be used e.g. in a timer handler shared across multiple subsystems to\n * retrieve data specific to the subsystem this timer is associated with.\n *\n * @param timer     Address of timer.\n * @param user_data User data to associate with the timer.\n */\n__syscall void k_timer_user_data_set(struct k_timer *timer, void *user_data);\n\n/**\n * @internal\n */\nstatic inline void z_impl_k_timer_user_data_set(struct k_timer *timer,\n\t\t\t\t\t       void *user_data)\n{\n\ttimer-&gt;user_data = user_data;\n}\n\n/**\n * @brief Retrieve the user-specific data from a timer.\n *\n * @param timer     Address of timer.\n *\n * @return The user data.\n */\n__syscall void *k_timer_user_data_get(const struct k_timer *timer);\n\nstatic inline void *z_impl_k_timer_user_data_get(const struct k_timer *timer)\n{\n\treturn timer-&gt;user_data;\n}\n\n/** @} */\n\n/**\n * @addtogroup clock_apis\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Get system uptime, in system ticks.\n *\n * This routine returns the elapsed time since the system booted, in\n * ticks (c.f. @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC}), which is the\n * fundamental unit of resolution of kernel timekeeping.\n *\n * @return Current uptime in ticks.\n */\n__syscall int64_t k_uptime_ticks(void);\n\n/**\n * @brief Get system uptime.\n *\n * This routine returns the elapsed time since the system booted,\n * in milliseconds.\n *\n * @note\n *    While this function returns time in milliseconds, it does\n *    not mean it has millisecond resolution. The actual resolution depends on\n *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option.\n *\n * @return Current uptime in milliseconds.\n */\nstatic inline int64_t k_uptime_get(void)\n{\n\treturn k_ticks_to_ms_floor64(k_uptime_ticks());\n}\n\n/**\n * @brief Get system uptime (32-bit version).\n *\n * This routine returns the lower 32 bits of the system uptime in\n * milliseconds.\n *\n * Because correct conversion requires full precision of the system\n * clock there is no benefit to using this over k_uptime_get() unless\n * you know the application will never run long enough for the system\n * clock to approach 2^32 ticks.  Calls to this function may involve\n * interrupt blocking and 64-bit math.\n *\n * @note\n *    While this function returns time in milliseconds, it does\n *    not mean it has millisecond resolution. The actual resolution depends on\n *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option\n *\n * @return The low 32 bits of the current uptime, in milliseconds.\n */\nstatic inline uint32_t k_uptime_get_32(void)\n{\n\treturn (uint32_t)k_uptime_get();\n}\n\n/**\n * @brief Get system uptime in seconds.\n *\n * This routine returns the elapsed time since the system booted,\n * in seconds.\n *\n * @return Current uptime in seconds.\n */\nstatic inline uint32_t k_uptime_seconds(void)\n{\n\treturn k_ticks_to_sec_floor32(k_uptime_ticks());\n}\n\n/**\n * @brief Get elapsed time.\n *\n * This routine computes the elapsed time between the current system uptime\n * and an earlier reference time, in milliseconds.\n *\n * @param reftime Pointer to a reference time, which is updated to the current\n *                uptime upon return.\n *\n * @return Elapsed time.\n */\nstatic inline int64_t k_uptime_delta(int64_t *reftime)\n{\n\tint64_t uptime, delta;\n\n\tuptime = k_uptime_get();\n\tdelta = uptime - *reftime;\n\t*reftime = uptime;\n\n\treturn delta;\n}\n\n/**\n * @brief Read the hardware clock.\n *\n * This routine returns the current time, as measured by the system&#x27;s hardware\n * clock.\n *\n * @return Current hardware clock up-counter (in cycles).\n */\nstatic inline uint32_t k_cycle_get_32(void)\n{\n\treturn arch_k_cycle_get_32();\n}\n\n/**\n * @brief Read the 64-bit hardware clock.\n *\n * This routine returns the current time in 64-bits, as measured by the\n * system&#x27;s hardware clock, if available.\n *\n * @see CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER\n *\n * @return Current hardware clock up-counter (in cycles).\n */\nstatic inline uint64_t k_cycle_get_64(void)\n{\n\tif (!IS_ENABLED(CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER)) {\n\t\t__ASSERT(0, &quot;64-bit cycle counter not enabled on this platform. &quot;\n\t\t\t    &quot;See CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER&quot;);\n\t\treturn 0;\n\t}\n\n\treturn arch_k_cycle_get_64();\n}\n\n/**\n * @}\n */\n\nstruct k_queue {\n\tsys_sflist_t data_q;\n\tstruct k_spinlock lock;\n\t_wait_q_t wait_q;\n\n\tZ_DECL_POLL_EVENT\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_queue)\n};\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n#define Z_QUEUE_INITIALIZER(obj) \\\n\t{ \\\n\t.data_q = SYS_SFLIST_STATIC_INIT(&amp;obj.data_q), \\\n\t.lock = { }, \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;obj.wait_q),\t\\\n\tZ_POLL_EVENT_OBJ_INIT(obj)\t\t\\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup queue_apis Queue APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Initialize a queue.\n *\n * This routine initializes a queue object, prior to its first use.\n *\n * @param queue Address of the queue.\n */\n__syscall void k_queue_init(struct k_queue *queue);\n\n/**\n * @brief Cancel waiting on a queue.\n *\n * This routine causes first thread pending on @a queue, if any, to\n * return from k_queue_get() call with NULL value (as if timeout expired).\n * If the queue is being waited on by k_poll(), it will return with\n * -EINTR and K_POLL_STATE_CANCELLED state (and per above, subsequent\n * k_queue_get() will return NULL).\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n */\n__syscall void k_queue_cancel_wait(struct k_queue *queue);\n\n/**\n * @brief Append an element to the end of a queue.\n *\n * This routine appends a data item to @a queue. A queue data item must be\n * aligned on a word boundary, and the first word of the item is reserved\n * for the kernel&#x27;s use.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param data Address of the data item.\n */\nvoid k_queue_append(struct k_queue *queue, void *data);\n\n/**\n * @brief Append an element to a queue.\n *\n * This routine appends a data item to @a queue. There is an implicit memory\n * allocation to create an additional temporary bookkeeping data structure from\n * the calling thread&#x27;s resource pool, which is automatically freed when the\n * item is removed. The data itself is not copied.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param data Address of the data item.\n *\n * @retval 0 on success\n * @retval -ENOMEM if there isn&#x27;t sufficient RAM in the caller&#x27;s resource pool\n */\n__syscall int32_t k_queue_alloc_append(struct k_queue *queue, void *data);\n\n/**\n * @brief Prepend an element to a queue.\n *\n * This routine prepends a data item to @a queue. A queue data item must be\n * aligned on a word boundary, and the first word of the item is reserved\n * for the kernel&#x27;s use.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param data Address of the data item.\n */\nvoid k_queue_prepend(struct k_queue *queue, void *data);\n\n/**\n * @brief Prepend an element to a queue.\n *\n * This routine prepends a data item to @a queue. There is an implicit memory\n * allocation to create an additional temporary bookkeeping data structure from\n * the calling thread&#x27;s resource pool, which is automatically freed when the\n * item is removed. The data itself is not copied.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param data Address of the data item.\n *\n * @retval 0 on success\n * @retval -ENOMEM if there isn&#x27;t sufficient RAM in the caller&#x27;s resource pool\n */\n__syscall int32_t k_queue_alloc_prepend(struct k_queue *queue, void *data);\n\n/**\n * @brief Inserts an element to a queue.\n *\n * This routine inserts a data item to @a queue after previous item. A queue\n * data item must be aligned on a word boundary, and the first word of\n * the item is reserved for the kernel&#x27;s use.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param prev Address of the previous data item.\n * @param data Address of the data item.\n */\nvoid k_queue_insert(struct k_queue *queue, void *prev, void *data);\n\n/**\n * @brief Atomically append a list of elements to a queue.\n *\n * This routine adds a list of data items to @a queue in one operation.\n * The data items must be in a singly-linked list, with the first word\n * in each data item pointing to the next data item; the list must be\n * NULL-terminated.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param head Pointer to first node in singly-linked list.\n * @param tail Pointer to last node in singly-linked list.\n *\n * @retval 0 on success\n * @retval -EINVAL on invalid supplied data\n *\n */\nint k_queue_append_list(struct k_queue *queue, void *head, void *tail);\n\n/**\n * @brief Atomically add a list of elements to a queue.\n *\n * This routine adds a list of data items to @a queue in one operation.\n * The data items must be in a singly-linked list implemented using a\n * sys_slist_t object. Upon completion, the original list is empty.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param list Pointer to sys_slist_t object.\n *\n * @retval 0 on success\n * @retval -EINVAL on invalid data\n */\nint k_queue_merge_slist(struct k_queue *queue, sys_slist_t *list);\n\n/**\n * @brief Get an element from a queue.\n *\n * This routine removes first data item from @a queue. The first word of the\n * data item is reserved for the kernel&#x27;s use.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param timeout Waiting period to obtain a data item, or one of the special\n *                values K_NO_WAIT and K_FOREVER.\n *\n * @return Address of the data item if successful; NULL if returned\n * without waiting, or waiting period timed out.\n */\n__syscall void *k_queue_get(struct k_queue *queue, k_timeout_t timeout);\n\n/**\n * @brief Remove an element from a queue.\n *\n * This routine removes data item from @a queue. The first word of the\n * data item is reserved for the kernel&#x27;s use. Removing elements from k_queue\n * rely on sys_slist_find_and_remove which is not a constant time operation.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param data Address of the data item.\n *\n * @return true if data item was removed\n */\nbool k_queue_remove(struct k_queue *queue, void *data);\n\n/**\n * @brief Append an element to a queue only if it&#x27;s not present already.\n *\n * This routine appends data item to @a queue. The first word of the data\n * item is reserved for the kernel&#x27;s use. Appending elements to k_queue\n * relies on sys_slist_is_node_in_list which is not a constant time operation.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n * @param data Address of the data item.\n *\n * @return true if data item was added, false if not\n */\nbool k_queue_unique_append(struct k_queue *queue, void *data);\n\n/**\n * @brief Query a queue to see if it has data available.\n *\n * Note that the data might be already gone by the time this function returns\n * if other threads are also trying to read from the queue.\n *\n * @funcprops \\isr_ok\n *\n * @param queue Address of the queue.\n *\n * @return Non-zero if the queue is empty.\n * @return 0 if data is available.\n */\n__syscall int k_queue_is_empty(struct k_queue *queue);\n\nstatic inline int z_impl_k_queue_is_empty(struct k_queue *queue)\n{\n\treturn sys_sflist_is_empty(&amp;queue-&gt;data_q) ? 1 : 0;\n}\n\n/**\n * @brief Peek element at the head of queue.\n *\n * Return element from the head of queue without removing it.\n *\n * @param queue Address of the queue.\n *\n * @return Head element, or NULL if queue is empty.\n */\n__syscall void *k_queue_peek_head(struct k_queue *queue);\n\n/**\n * @brief Peek element at the tail of queue.\n *\n * Return element from the tail of queue without removing it.\n *\n * @param queue Address of the queue.\n *\n * @return Tail element, or NULL if queue is empty.\n */\n__syscall void *k_queue_peek_tail(struct k_queue *queue);\n\n/**\n * @brief Statically define and initialize a queue.\n *\n * The queue can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_queue &lt;name&gt;; @endcode\n *\n * @param name Name of the queue.\n */\n#define K_QUEUE_DEFINE(name) \\\n\tSTRUCT_SECTION_ITERABLE(k_queue, name) = \\\n\t\tZ_QUEUE_INITIALIZER(name)\n\n/** @} */\n\n#ifdef CONFIG_USERSPACE\n/**\n * @brief futex structure\n *\n * A k_futex is a lightweight mutual exclusion primitive designed\n * to minimize kernel involvement. Uncontended operation relies\n * only on atomic access to shared memory. k_futex are tracked as\n * kernel objects and can live in user memory so that any access\n * bypasses the kernel object permission management mechanism.\n */\nstruct k_futex {\n\tatomic_t val;\n};\n\n/**\n * @brief futex kernel data structure\n *\n * z_futex_data are the helper data structure for k_futex to complete\n * futex contended operation on kernel side, structure z_futex_data\n * of every futex object is invisible in user mode.\n */\nstruct z_futex_data {\n\t_wait_q_t wait_q;\n\tstruct k_spinlock lock;\n};\n\n#define Z_FUTEX_DATA_INITIALIZER(obj) \\\n\t{ \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;obj.wait_q) \\\n\t}\n\n/**\n * @defgroup futex_apis FUTEX APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Pend the current thread on a futex\n *\n * Tests that the supplied futex contains the expected value, and if so,\n * goes to sleep until some other thread calls k_futex_wake() on it.\n *\n * @param futex Address of the futex.\n * @param expected Expected value of the futex, if it is different the caller\n *\t\t   will not wait on it.\n * @param timeout Waiting period on the futex, or one of the special values\n *                K_NO_WAIT or K_FOREVER.\n * @retval -EACCES Caller does not have read access to futex address.\n * @retval -EAGAIN If the futex value did not match the expected parameter.\n * @retval -EINVAL Futex parameter address not recognized by the kernel.\n * @retval -ETIMEDOUT Thread woke up due to timeout and not a futex wakeup.\n * @retval 0 if the caller went to sleep and was woken up. The caller\n *\t     should check the futex&#x27;s value on wakeup to determine if it needs\n *\t     to block again.\n */\n__syscall int k_futex_wait(struct k_futex *futex, int expected,\n\t\t\t   k_timeout_t timeout);\n\n/**\n * @brief Wake one/all threads pending on a futex\n *\n * Wake up the highest priority thread pending on the supplied futex, or\n * wakeup all the threads pending on the supplied futex, and the behavior\n * depends on wake_all.\n *\n * @param futex Futex to wake up pending threads.\n * @param wake_all If true, wake up all pending threads; If false,\n *                 wakeup the highest priority thread.\n * @retval -EACCES Caller does not have access to the futex address.\n * @retval -EINVAL Futex parameter address not recognized by the kernel.\n * @retval Number of threads that were woken up.\n */\n__syscall int k_futex_wake(struct k_futex *futex, bool wake_all);\n\n/** @} */\n#endif\n\n/**\n * @defgroup event_apis Event APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * Event Structure\n * @ingroup event_apis\n */\n\nstruct k_event {\n\t_wait_q_t         wait_q;\n\tuint32_t          events;\n\tstruct k_spinlock lock;\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_event)\n\n#ifdef CONFIG_OBJ_CORE_EVENT\n\tstruct k_obj_core obj_core;\n#endif\n\n};\n\n#define Z_EVENT_INITIALIZER(obj) \\\n\t{ \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;obj.wait_q), \\\n\t.events = 0 \\\n\t}\n\n/**\n * @brief Initialize an event object\n *\n * This routine initializes an event object, prior to its first use.\n *\n * @param event Address of the event object.\n */\n__syscall void k_event_init(struct k_event *event);\n\n/**\n * @brief Post one or more events to an event object\n *\n * This routine posts one or more events to an event object. All tasks waiting\n * on the event object @a event whose waiting conditions become met by this\n * posting immediately unpend.\n *\n * Posting differs from setting in that posted events are merged together with\n * the current set of events tracked by the event object.\n *\n * @param event Address of the event object\n * @param events Set of events to post to @a event\n *\n * @retval Previous value of the events in @a event\n */\n__syscall uint32_t k_event_post(struct k_event *event, uint32_t events);\n\n/**\n * @brief Set the events in an event object\n *\n * This routine sets the events stored in event object to the specified value.\n * All tasks waiting on the event object @a event whose waiting conditions\n * become met by this immediately unpend.\n *\n * Setting differs from posting in that set events replace the current set of\n * events tracked by the event object.\n *\n * @param event Address of the event object\n * @param events Set of events to set in @a event\n *\n * @retval Previous value of the events in @a event\n */\n__syscall uint32_t k_event_set(struct k_event *event, uint32_t events);\n\n/**\n * @brief Set or clear the events in an event object\n *\n * This routine sets the events stored in event object to the specified value.\n * All tasks waiting on the event object @a event whose waiting conditions\n * become met by this immediately unpend. Unlike @ref k_event_set, this routine\n * allows specific event bits to be set and cleared as determined by the mask.\n *\n * @param event Address of the event object\n * @param events Set of events to set/clear in @a event\n * @param events_mask Mask to be applied to @a events\n *\n * @retval Previous value of the events in @a events_mask\n */\n__syscall uint32_t k_event_set_masked(struct k_event *event, uint32_t events,\n\t\t\t\t  uint32_t events_mask);\n\n/**\n * @brief Clear the events in an event object\n *\n * This routine clears (resets) the specified events stored in an event object.\n *\n * @param event Address of the event object\n * @param events Set of events to clear in @a event\n *\n * @retval Previous value of the events in @a event\n */\n__syscall uint32_t k_event_clear(struct k_event *event, uint32_t events);\n\n/**\n * @brief Wait for any of the specified events\n *\n * This routine waits on event object @a event until any of the specified\n * events have been delivered to the event object, or the maximum wait time\n * @a timeout has expired. A thread may wait on up to 32 distinctly numbered\n * events that are expressed as bits in a single 32-bit word.\n *\n * @note The caller must be careful when resetting if there are multiple threads\n * waiting for the event object @a event.\n *\n * @param event Address of the event object\n * @param events Set of desired events on which to wait\n * @param reset If true, clear the set of events tracked by the event object\n *              before waiting. If false, do not clear the events.\n * @param timeout Waiting period for the desired set of events or one of the\n *                special values K_NO_WAIT and K_FOREVER.\n *\n * @retval set of matching events upon success\n * @retval 0 if matching events were not received within the specified time\n */\n__syscall uint32_t k_event_wait(struct k_event *event, uint32_t events,\n\t\t\t\tbool reset, k_timeout_t timeout);\n\n/**\n * @brief Wait for all of the specified events\n *\n * This routine waits on event object @a event until all of the specified\n * events have been delivered to the event object, or the maximum wait time\n * @a timeout has expired. A thread may wait on up to 32 distinctly numbered\n * events that are expressed as bits in a single 32-bit word.\n *\n * @note The caller must be careful when resetting if there are multiple threads\n * waiting for the event object @a event.\n *\n * @param event Address of the event object\n * @param events Set of desired events on which to wait\n * @param reset If true, clear the set of events tracked by the event object\n *              before waiting. If false, do not clear the events.\n * @param timeout Waiting period for the desired set of events or one of the\n *                special values K_NO_WAIT and K_FOREVER.\n *\n * @retval set of matching events upon success\n * @retval 0 if matching events were not received within the specified time\n */\n__syscall uint32_t k_event_wait_all(struct k_event *event, uint32_t events,\n\t\t\t\t    bool reset, k_timeout_t timeout);\n\n/**\n * @brief Test the events currently tracked in the event object\n *\n * @param event Address of the event object\n * @param events_mask Set of desired events to test\n *\n * @retval Current value of events in @a events_mask\n */\nstatic inline uint32_t k_event_test(struct k_event *event, uint32_t events_mask)\n{\n\treturn k_event_wait(event, events_mask, false, K_NO_WAIT);\n}\n\n/**\n * @brief Statically define and initialize an event object\n *\n * The event can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_event &lt;name&gt;; @endcode\n *\n * @param name Name of the event object.\n */\n#define K_EVENT_DEFINE(name)                                   \\\n\tSTRUCT_SECTION_ITERABLE(k_event, name) =               \\\n\t\tZ_EVENT_INITIALIZER(name);\n\n/** @} */\n\nstruct k_fifo {\n\tstruct k_queue _queue;\n#ifdef CONFIG_OBJ_CORE_FIFO\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n#define Z_FIFO_INITIALIZER(obj) \\\n\t{ \\\n\t._queue = Z_QUEUE_INITIALIZER(obj._queue) \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup fifo_apis FIFO APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Initialize a FIFO queue.\n *\n * This routine initializes a FIFO queue, prior to its first use.\n *\n * @param fifo Address of the FIFO queue.\n */\n#define k_fifo_init(fifo)                                    \\\n\t({                                                   \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, init, fifo); \\\n\tk_queue_init(&amp;(fifo)-&gt;_queue);                       \\\n\tK_OBJ_CORE_INIT(K_OBJ_CORE(fifo), _obj_type_fifo);   \\\n\tK_OBJ_CORE_LINK(K_OBJ_CORE(fifo));                   \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, init, fifo);  \\\n\t})\n\n/**\n * @brief Cancel waiting on a FIFO queue.\n *\n * This routine causes first thread pending on @a fifo, if any, to\n * return from k_fifo_get() call with NULL value (as if timeout\n * expired).\n *\n * @funcprops \\isr_ok\n *\n * @param fifo Address of the FIFO queue.\n */\n#define k_fifo_cancel_wait(fifo) \\\n\t({ \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, cancel_wait, fifo); \\\n\tk_queue_cancel_wait(&amp;(fifo)-&gt;_queue); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, cancel_wait, fifo); \\\n\t})\n\n/**\n * @brief Add an element to a FIFO queue.\n *\n * This routine adds a data item to @a fifo. A FIFO data item must be\n * aligned on a word boundary, and the first word of the item is reserved\n * for the kernel&#x27;s use.\n *\n * @funcprops \\isr_ok\n *\n * @param fifo Address of the FIFO.\n * @param data Address of the data item.\n */\n#define k_fifo_put(fifo, data) \\\n\t({ \\\n\tvoid *_data = data; \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, put, fifo, _data); \\\n\tk_queue_append(&amp;(fifo)-&gt;_queue, _data); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, put, fifo, _data); \\\n\t})\n\n/**\n * @brief Add an element to a FIFO queue.\n *\n * This routine adds a data item to @a fifo. There is an implicit memory\n * allocation to create an additional temporary bookkeeping data structure from\n * the calling thread&#x27;s resource pool, which is automatically freed when the\n * item is removed. The data itself is not copied.\n *\n * @funcprops \\isr_ok\n *\n * @param fifo Address of the FIFO.\n * @param data Address of the data item.\n *\n * @retval 0 on success\n * @retval -ENOMEM if there isn&#x27;t sufficient RAM in the caller&#x27;s resource pool\n */\n#define k_fifo_alloc_put(fifo, data) \\\n\t({ \\\n\tvoid *_data = data; \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, alloc_put, fifo, _data); \\\n\tint fap_ret = k_queue_alloc_append(&amp;(fifo)-&gt;_queue, _data); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, alloc_put, fifo, _data, fap_ret); \\\n\tfap_ret; \\\n\t})\n\n/**\n * @brief Atomically add a list of elements to a FIFO.\n *\n * This routine adds a list of data items to @a fifo in one operation.\n * The data items must be in a singly-linked list, with the first word of\n * each data item pointing to the next data item; the list must be\n * NULL-terminated.\n *\n * @funcprops \\isr_ok\n *\n * @param fifo Address of the FIFO queue.\n * @param head Pointer to first node in singly-linked list.\n * @param tail Pointer to last node in singly-linked list.\n */\n#define k_fifo_put_list(fifo, head, tail) \\\n\t({ \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, put_list, fifo, head, tail); \\\n\tk_queue_append_list(&amp;(fifo)-&gt;_queue, head, tail); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, put_list, fifo, head, tail); \\\n\t})\n\n/**\n * @brief Atomically add a list of elements to a FIFO queue.\n *\n * This routine adds a list of data items to @a fifo in one operation.\n * The data items must be in a singly-linked list implemented using a\n * sys_slist_t object. Upon completion, the sys_slist_t object is invalid\n * and must be re-initialized via sys_slist_init().\n *\n * @funcprops \\isr_ok\n *\n * @param fifo Address of the FIFO queue.\n * @param list Pointer to sys_slist_t object.\n */\n#define k_fifo_put_slist(fifo, list) \\\n\t({ \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, put_slist, fifo, list); \\\n\tk_queue_merge_slist(&amp;(fifo)-&gt;_queue, list); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, put_slist, fifo, list); \\\n\t})\n\n/**\n * @brief Get an element from a FIFO queue.\n *\n * This routine removes a data item from @a fifo in a &quot;first in, first out&quot;\n * manner. The first word of the data item is reserved for the kernel&#x27;s use.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n *\n * @funcprops \\isr_ok\n *\n * @param fifo Address of the FIFO queue.\n * @param timeout Waiting period to obtain a data item,\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n *\n * @return Address of the data item if successful; NULL if returned\n * without waiting, or waiting period timed out.\n */\n#define k_fifo_get(fifo, timeout) \\\n\t({ \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, get, fifo, timeout); \\\n\tvoid *fg_ret = k_queue_get(&amp;(fifo)-&gt;_queue, timeout); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, get, fifo, timeout, fg_ret); \\\n\tfg_ret; \\\n\t})\n\n/**\n * @brief Query a FIFO queue to see if it has data available.\n *\n * Note that the data might be already gone by the time this function returns\n * if other threads is also trying to read from the FIFO.\n *\n * @funcprops \\isr_ok\n *\n * @param fifo Address of the FIFO queue.\n *\n * @return Non-zero if the FIFO queue is empty.\n * @return 0 if data is available.\n */\n#define k_fifo_is_empty(fifo) \\\n\tk_queue_is_empty(&amp;(fifo)-&gt;_queue)\n\n/**\n * @brief Peek element at the head of a FIFO queue.\n *\n * Return element from the head of FIFO queue without removing it. A usecase\n * for this is if elements of the FIFO object are themselves containers. Then\n * on each iteration of processing, a head container will be peeked,\n * and some data processed out of it, and only if the container is empty,\n * it will be completely remove from the FIFO queue.\n *\n * @param fifo Address of the FIFO queue.\n *\n * @return Head element, or NULL if the FIFO queue is empty.\n */\n#define k_fifo_peek_head(fifo) \\\n\t({ \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, peek_head, fifo); \\\n\tvoid *fph_ret = k_queue_peek_head(&amp;(fifo)-&gt;_queue); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, peek_head, fifo, fph_ret); \\\n\tfph_ret; \\\n\t})\n\n/**\n * @brief Peek element at the tail of FIFO queue.\n *\n * Return element from the tail of FIFO queue (without removing it). A usecase\n * for this is if elements of the FIFO queue are themselves containers. Then\n * it may be useful to add more data to the last container in a FIFO queue.\n *\n * @param fifo Address of the FIFO queue.\n *\n * @return Tail element, or NULL if a FIFO queue is empty.\n */\n#define k_fifo_peek_tail(fifo) \\\n\t({ \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_fifo, peek_tail, fifo); \\\n\tvoid *fpt_ret = k_queue_peek_tail(&amp;(fifo)-&gt;_queue); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_fifo, peek_tail, fifo, fpt_ret); \\\n\tfpt_ret; \\\n\t})\n\n/**\n * @brief Statically define and initialize a FIFO queue.\n *\n * The FIFO queue can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_fifo &lt;name&gt;; @endcode\n *\n * @param name Name of the FIFO queue.\n */\n#define K_FIFO_DEFINE(name) \\\n\tSTRUCT_SECTION_ITERABLE(k_fifo, name) = \\\n\t\tZ_FIFO_INITIALIZER(name)\n\n/** @} */\n\nstruct k_lifo {\n\tstruct k_queue _queue;\n#ifdef CONFIG_OBJ_CORE_LIFO\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n#define Z_LIFO_INITIALIZER(obj) \\\n\t{ \\\n\t._queue = Z_QUEUE_INITIALIZER(obj._queue) \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup lifo_apis LIFO APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Initialize a LIFO queue.\n *\n * This routine initializes a LIFO queue object, prior to its first use.\n *\n * @param lifo Address of the LIFO queue.\n */\n#define k_lifo_init(lifo)                                    \\\n\t({                                                   \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_lifo, init, lifo); \\\n\tk_queue_init(&amp;(lifo)-&gt;_queue);                       \\\n\tK_OBJ_CORE_INIT(K_OBJ_CORE(lifo), _obj_type_lifo);   \\\n\tK_OBJ_CORE_LINK(K_OBJ_CORE(lifo));                   \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_lifo, init, lifo);  \\\n\t})\n\n/**\n * @brief Add an element to a LIFO queue.\n *\n * This routine adds a data item to @a lifo. A LIFO queue data item must be\n * aligned on a word boundary, and the first word of the item is\n * reserved for the kernel&#x27;s use.\n *\n * @funcprops \\isr_ok\n *\n * @param lifo Address of the LIFO queue.\n * @param data Address of the data item.\n */\n#define k_lifo_put(lifo, data) \\\n\t({ \\\n\tvoid *_data = data; \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_lifo, put, lifo, _data); \\\n\tk_queue_prepend(&amp;(lifo)-&gt;_queue, _data); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_lifo, put, lifo, _data); \\\n\t})\n\n/**\n * @brief Add an element to a LIFO queue.\n *\n * This routine adds a data item to @a lifo. There is an implicit memory\n * allocation to create an additional temporary bookkeeping data structure from\n * the calling thread&#x27;s resource pool, which is automatically freed when the\n * item is removed. The data itself is not copied.\n *\n * @funcprops \\isr_ok\n *\n * @param lifo Address of the LIFO.\n * @param data Address of the data item.\n *\n * @retval 0 on success\n * @retval -ENOMEM if there isn&#x27;t sufficient RAM in the caller&#x27;s resource pool\n */\n#define k_lifo_alloc_put(lifo, data) \\\n\t({ \\\n\tvoid *_data = data; \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_lifo, alloc_put, lifo, _data); \\\n\tint lap_ret = k_queue_alloc_prepend(&amp;(lifo)-&gt;_queue, _data); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_lifo, alloc_put, lifo, _data, lap_ret); \\\n\tlap_ret; \\\n\t})\n\n/**\n * @brief Get an element from a LIFO queue.\n *\n * This routine removes a data item from @a LIFO in a &quot;last in, first out&quot;\n * manner. The first word of the data item is reserved for the kernel&#x27;s use.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n *\n * @funcprops \\isr_ok\n *\n * @param lifo Address of the LIFO queue.\n * @param timeout Waiting period to obtain a data item,\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n *\n * @return Address of the data item if successful; NULL if returned\n * without waiting, or waiting period timed out.\n */\n#define k_lifo_get(lifo, timeout) \\\n\t({ \\\n\tSYS_PORT_TRACING_OBJ_FUNC_ENTER(k_lifo, get, lifo, timeout); \\\n\tvoid *lg_ret = k_queue_get(&amp;(lifo)-&gt;_queue, timeout); \\\n\tSYS_PORT_TRACING_OBJ_FUNC_EXIT(k_lifo, get, lifo, timeout, lg_ret); \\\n\tlg_ret; \\\n\t})\n\n/**\n * @brief Statically define and initialize a LIFO queue.\n *\n * The LIFO queue can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_lifo &lt;name&gt;; @endcode\n *\n * @param name Name of the fifo.\n */\n#define K_LIFO_DEFINE(name) \\\n\tSTRUCT_SECTION_ITERABLE(k_lifo, name) = \\\n\t\tZ_LIFO_INITIALIZER(name)\n\n/** @} */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n#define K_STACK_FLAG_ALLOC\t((uint8_t)1)\t/* Buffer was allocated */\n\ntypedef uintptr_t stack_data_t;\n\nstruct k_stack {\n\t_wait_q_t wait_q;\n\tstruct k_spinlock lock;\n\tstack_data_t *base, *next, *top;\n\n\tuint8_t flags;\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_stack)\n\n#ifdef CONFIG_OBJ_CORE_STACK\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n#define Z_STACK_INITIALIZER(obj, stack_buffer, stack_num_entries) \\\n\t{ \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;(obj).wait_q),\t\\\n\t.base = (stack_buffer), \\\n\t.next = (stack_buffer), \\\n\t.top = (stack_buffer) + (stack_num_entries), \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup stack_apis Stack APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Initialize a stack.\n *\n * This routine initializes a stack object, prior to its first use.\n *\n * @param stack Address of the stack.\n * @param buffer Address of array used to hold stacked values.\n * @param num_entries Maximum number of values that can be stacked.\n */\nvoid k_stack_init(struct k_stack *stack,\n\t\t  stack_data_t *buffer, uint32_t num_entries);\n\n\n/**\n * @brief Initialize a stack.\n *\n * This routine initializes a stack object, prior to its first use. Internal\n * buffers will be allocated from the calling thread&#x27;s resource pool.\n * This memory will be released if k_stack_cleanup() is called, or\n * userspace is enabled and the stack object loses all references to it.\n *\n * @param stack Address of the stack.\n * @param num_entries Maximum number of values that can be stacked.\n *\n * @return -ENOMEM if memory couldn&#x27;t be allocated\n */\n\n__syscall int32_t k_stack_alloc_init(struct k_stack *stack,\n\t\t\t\t   uint32_t num_entries);\n\n/**\n * @brief Release a stack&#x27;s allocated buffer\n *\n * If a stack object was given a dynamically allocated buffer via\n * k_stack_alloc_init(), this will free it. This function does nothing\n * if the buffer wasn&#x27;t dynamically allocated.\n *\n * @param stack Address of the stack.\n * @retval 0 on success\n * @retval -EAGAIN when object is still in use\n */\nint k_stack_cleanup(struct k_stack *stack);\n\n/**\n * @brief Push an element onto a stack.\n *\n * This routine adds a stack_data_t value @a data to @a stack.\n *\n * @funcprops \\isr_ok\n *\n * @param stack Address of the stack.\n * @param data Value to push onto the stack.\n *\n * @retval 0 on success\n * @retval -ENOMEM if stack is full\n */\n__syscall int k_stack_push(struct k_stack *stack, stack_data_t data);\n\n/**\n * @brief Pop an element from a stack.\n *\n * This routine removes a stack_data_t value from @a stack in a &quot;last in,\n * first out&quot; manner and stores the value in @a data.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n *\n * @funcprops \\isr_ok\n *\n * @param stack Address of the stack.\n * @param data Address of area to hold the value popped from the stack.\n * @param timeout Waiting period to obtain a value,\n *                or one of the special values K_NO_WAIT and\n *                K_FOREVER.\n *\n * @retval 0 Element popped from stack.\n * @retval -EBUSY Returned without waiting.\n * @retval -EAGAIN Waiting period timed out.\n */\n__syscall int k_stack_pop(struct k_stack *stack, stack_data_t *data,\n\t\t\t  k_timeout_t timeout);\n\n/**\n * @brief Statically define and initialize a stack\n *\n * The stack can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_stack &lt;name&gt;; @endcode\n *\n * @param name Name of the stack.\n * @param stack_num_entries Maximum number of values that can be stacked.\n */\n#define K_STACK_DEFINE(name, stack_num_entries)                \\\n\tstack_data_t __noinit                                  \\\n\t\t_k_stack_buf_##name[stack_num_entries];        \\\n\tSTRUCT_SECTION_ITERABLE(k_stack, name) =               \\\n\t\tZ_STACK_INITIALIZER(name, _k_stack_buf_##name, \\\n\t\t\t\t    stack_num_entries)\n\n/** @} */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\nstruct k_work;\nstruct k_work_q;\nstruct k_work_queue_config;\nextern struct k_work_q k_sys_work_q;\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup mutex_apis Mutex APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * Mutex Structure\n * @ingroup mutex_apis\n */\nstruct k_mutex {\n\t/** Mutex wait queue */\n\t_wait_q_t wait_q;\n\t/** Mutex owner */\n\tstruct k_thread *owner;\n\n\t/** Current lock count */\n\tuint32_t lock_count;\n\n\t/** Original thread priority */\n\tint owner_orig_prio;\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_mutex)\n\n#ifdef CONFIG_OBJ_CORE_MUTEX\n\tstruct k_obj_core obj_core;\n#endif\n};\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n#define Z_MUTEX_INITIALIZER(obj) \\\n\t{ \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;(obj).wait_q), \\\n\t.owner = NULL, \\\n\t.lock_count = 0, \\\n\t.owner_orig_prio = K_LOWEST_APPLICATION_THREAD_PRIO, \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @brief Statically define and initialize a mutex.\n *\n * The mutex can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_mutex &lt;name&gt;; @endcode\n *\n * @param name Name of the mutex.\n */\n#define K_MUTEX_DEFINE(name) \\\n\tSTRUCT_SECTION_ITERABLE(k_mutex, name) = \\\n\t\tZ_MUTEX_INITIALIZER(name)\n\n/**\n * @brief Initialize a mutex.\n *\n * This routine initializes a mutex object, prior to its first use.\n *\n * Upon completion, the mutex is available and does not have an owner.\n *\n * @param mutex Address of the mutex.\n *\n * @retval 0 Mutex object created\n *\n */\n__syscall int k_mutex_init(struct k_mutex *mutex);\n\n\n/**\n * @brief Lock a mutex.\n *\n * This routine locks @a mutex. If the mutex is locked by another thread,\n * the calling thread waits until the mutex becomes available or until\n * a timeout occurs.\n *\n * A thread is permitted to lock a mutex it has already locked. The operation\n * completes immediately and the lock count is increased by 1.\n *\n * Mutexes may not be locked in ISRs.\n *\n * @param mutex Address of the mutex.\n * @param timeout Waiting period to lock the mutex,\n *                or one of the special values K_NO_WAIT and\n *                K_FOREVER.\n *\n * @retval 0 Mutex locked.\n * @retval -EBUSY Returned without waiting.\n * @retval -EAGAIN Waiting period timed out.\n */\n__syscall int k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout);\n\n/**\n * @brief Unlock a mutex.\n *\n * This routine unlocks @a mutex. The mutex must already be locked by the\n * calling thread.\n *\n * The mutex cannot be claimed by another thread until it has been unlocked by\n * the calling thread as many times as it was previously locked by that\n * thread.\n *\n * Mutexes may not be unlocked in ISRs, as mutexes must only be manipulated\n * in thread context due to ownership and priority inheritance semantics.\n *\n * @param mutex Address of the mutex.\n *\n * @retval 0 Mutex unlocked.\n * @retval -EPERM The current thread does not own the mutex\n * @retval -EINVAL The mutex is not locked\n *\n */\n__syscall int k_mutex_unlock(struct k_mutex *mutex);\n\n/**\n * @}\n */\n\n\nstruct k_condvar {\n\t_wait_q_t wait_q;\n\n#ifdef CONFIG_OBJ_CORE_CONDVAR\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n#define Z_CONDVAR_INITIALIZER(obj)                                             \\\n\t{                                                                      \\\n\t\t.wait_q = Z_WAIT_Q_INIT(&amp;obj.wait_q),                          \\\n\t}\n\n/**\n * @defgroup condvar_apis Condition Variables APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Initialize a condition variable\n *\n * @param condvar pointer to a @p k_condvar structure\n * @retval 0 Condition variable created successfully\n */\n__syscall int k_condvar_init(struct k_condvar *condvar);\n\n/**\n * @brief Signals one thread that is pending on the condition variable\n *\n * @param condvar pointer to a @p k_condvar structure\n * @retval 0 On success\n */\n__syscall int k_condvar_signal(struct k_condvar *condvar);\n\n/**\n * @brief Unblock all threads that are pending on the condition\n * variable\n *\n * @param condvar pointer to a @p k_condvar structure\n * @return An integer with number of woken threads on success\n */\n__syscall int k_condvar_broadcast(struct k_condvar *condvar);\n\n/**\n * @brief Waits on the condition variable releasing the mutex lock\n *\n * Atomically releases the currently owned mutex, blocks the current thread\n * waiting on the condition variable specified by @a condvar,\n * and finally acquires the mutex again.\n *\n * The waiting thread unblocks only after another thread calls\n * k_condvar_signal, or k_condvar_broadcast with the same condition variable.\n *\n * @param condvar pointer to a @p k_condvar structure\n * @param mutex Address of the mutex.\n * @param timeout Waiting period for the condition variable\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n * @retval 0 On success\n * @retval -EAGAIN Waiting period timed out.\n */\n__syscall int k_condvar_wait(struct k_condvar *condvar, struct k_mutex *mutex,\n\t\t\t     k_timeout_t timeout);\n\n/**\n * @brief Statically define and initialize a condition variable.\n *\n * The condition variable can be accessed outside the module where it is\n * defined using:\n *\n * @code extern struct k_condvar &lt;name&gt;; @endcode\n *\n * @param name Name of the condition variable.\n */\n#define K_CONDVAR_DEFINE(name)                                                 \\\n\tSTRUCT_SECTION_ITERABLE(k_condvar, name) =                             \\\n\t\tZ_CONDVAR_INITIALIZER(name)\n/**\n * @}\n */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\nstruct k_sem {\n\t_wait_q_t wait_q;\n\tunsigned int count;\n\tunsigned int limit;\n\n\tZ_DECL_POLL_EVENT\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_sem)\n\n#ifdef CONFIG_OBJ_CORE_SEM\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n#define Z_SEM_INITIALIZER(obj, initial_count, count_limit) \\\n\t{ \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;(obj).wait_q), \\\n\t.count = (initial_count), \\\n\t.limit = (count_limit), \\\n\tZ_POLL_EVENT_OBJ_INIT(obj) \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup semaphore_apis Semaphore APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Maximum limit value allowed for a semaphore.\n *\n * This is intended for use when a semaphore does not have\n * an explicit maximum limit, and instead is just used for\n * counting purposes.\n *\n */\n#define K_SEM_MAX_LIMIT UINT_MAX\n\n/**\n * @brief Initialize a semaphore.\n *\n * This routine initializes a semaphore object, prior to its first use.\n *\n * @param sem Address of the semaphore.\n * @param initial_count Initial semaphore count.\n * @param limit Maximum permitted semaphore count.\n *\n * @see K_SEM_MAX_LIMIT\n *\n * @retval 0 Semaphore created successfully\n * @retval -EINVAL Invalid values\n *\n */\n__syscall int k_sem_init(struct k_sem *sem, unsigned int initial_count,\n\t\t\t  unsigned int limit);\n\n/**\n * @brief Take a semaphore.\n *\n * This routine takes @a sem.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n *\n * @funcprops \\isr_ok\n *\n * @param sem Address of the semaphore.\n * @param timeout Waiting period to take the semaphore,\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n *\n * @retval 0 Semaphore taken.\n * @retval -EBUSY Returned without waiting.\n * @retval -EAGAIN Waiting period timed out,\n *\t\t\tor the semaphore was reset during the waiting period.\n */\n__syscall int k_sem_take(struct k_sem *sem, k_timeout_t timeout);\n\n/**\n * @brief Give a semaphore.\n *\n * This routine gives @a sem, unless the semaphore is already at its maximum\n * permitted count.\n *\n * @funcprops \\isr_ok\n *\n * @param sem Address of the semaphore.\n */\n__syscall void k_sem_give(struct k_sem *sem);\n\n/**\n * @brief Resets a semaphore&#x27;s count to zero.\n *\n * This routine sets the count of @a sem to zero.\n * Any outstanding semaphore takes will be aborted\n * with -EAGAIN.\n *\n * @param sem Address of the semaphore.\n */\n__syscall void k_sem_reset(struct k_sem *sem);\n\n/**\n * @brief Get a semaphore&#x27;s count.\n *\n * This routine returns the current count of @a sem.\n *\n * @param sem Address of the semaphore.\n *\n * @return Current semaphore count.\n */\n__syscall unsigned int k_sem_count_get(struct k_sem *sem);\n\n/**\n * @internal\n */\nstatic inline unsigned int z_impl_k_sem_count_get(struct k_sem *sem)\n{\n\treturn sem-&gt;count;\n}\n\n/**\n * @brief Statically define and initialize a semaphore.\n *\n * The semaphore can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_sem &lt;name&gt;; @endcode\n *\n * @param name Name of the semaphore.\n * @param initial_count Initial semaphore count.\n * @param count_limit Maximum permitted semaphore count.\n */\n#define K_SEM_DEFINE(name, initial_count, count_limit)                                             \\\n\tSTRUCT_SECTION_ITERABLE(k_sem, name) =                                                     \\\n\t\tZ_SEM_INITIALIZER(name, initial_count, count_limit);                               \\\n\tBUILD_ASSERT(((count_limit) != 0) &amp;&amp;                                                       \\\n\t\t     (((initial_count) &lt; (count_limit)) || ((initial_count) == (count_limit))) &amp;&amp;  \\\n\t\t     ((count_limit) &lt;= K_SEM_MAX_LIMIT));\n\n/** @} */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\nstruct k_work_delayable;\nstruct k_work_sync;\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup workqueue_apis Work Queue APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/** @brief The signature for a work item handler function.\n *\n * The function will be invoked by the thread animating a work queue.\n *\n * @param work the work item that provided the handler.\n */\ntypedef void (*k_work_handler_t)(struct k_work *work);\n\n/** @brief Initialize a (non-delayable) work structure.\n *\n * This must be invoked before submitting a work structure for the first time.\n * It need not be invoked again on the same work structure.  It can be\n * re-invoked to change the associated handler, but this must be done when the\n * work item is idle.\n *\n * @funcprops \\isr_ok\n *\n * @param work the work structure to be initialized.\n *\n * @param handler the handler to be invoked by the work item.\n */\nvoid k_work_init(struct k_work *work,\n\t\t  k_work_handler_t handler);\n\n/** @brief Busy state flags from the work item.\n *\n * A zero return value indicates the work item appears to be idle.\n *\n * @note This is a live snapshot of state, which may change before the result\n * is checked.  Use locks where appropriate.\n *\n * @funcprops \\isr_ok\n *\n * @param work pointer to the work item.\n *\n * @return a mask of flags K_WORK_DELAYED, K_WORK_QUEUED,\n * K_WORK_RUNNING, K_WORK_CANCELING, and K_WORK_FLUSHING.\n */\nint k_work_busy_get(const struct k_work *work);\n\n/** @brief Test whether a work item is currently pending.\n *\n * Wrapper to determine whether a work item is in a non-idle state.\n *\n * @note This is a live snapshot of state, which may change before the result\n * is checked.  Use locks where appropriate.\n *\n * @funcprops \\isr_ok\n *\n * @param work pointer to the work item.\n *\n * @return true if and only if k_work_busy_get() returns a non-zero value.\n */\nstatic inline bool k_work_is_pending(const struct k_work *work);\n\n/** @brief Submit a work item to a queue.\n *\n * @param queue pointer to the work queue on which the item should run.  If\n * NULL the queue from the most recent submission will be used.\n *\n * @funcprops \\isr_ok\n *\n * @param work pointer to the work item.\n *\n * @retval 0 if work was already submitted to a queue\n * @retval 1 if work was not submitted and has been queued to @p queue\n * @retval 2 if work was running and has been queued to the queue that was\n * running it\n * @retval -EBUSY\n * * if work submission was rejected because the work item is cancelling; or\n * * @p queue is draining; or\n * * @p queue is plugged.\n * @retval -EINVAL if @p queue is null and the work item has never been run.\n * @retval -ENODEV if @p queue has not been started.\n */\nint k_work_submit_to_queue(struct k_work_q *queue,\n\t\t\t   struct k_work *work);\n\n/** @brief Submit a work item to the system queue.\n *\n * @funcprops \\isr_ok\n *\n * @param work pointer to the work item.\n *\n * @return as with k_work_submit_to_queue().\n */\nint k_work_submit(struct k_work *work);\n\n/** @brief Wait for last-submitted instance to complete.\n *\n * Resubmissions may occur while waiting, including chained submissions (from\n * within the handler).\n *\n * @note Be careful of caller and work queue thread relative priority.  If\n * this function sleeps it will not return until the work queue thread\n * completes the tasks that allow this thread to resume.\n *\n * @note Behavior is undefined if this function is invoked on @p work from a\n * work queue running @p work.\n *\n * @param work pointer to the work item.\n *\n * @param sync pointer to an opaque item containing state related to the\n * pending cancellation.  The object must persist until the call returns, and\n * be accessible from both the caller thread and the work queue thread.  The\n * object must not be used for any other flush or cancel operation until this\n * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n * must be allocated in coherent memory.\n *\n * @retval true if call had to wait for completion\n * @retval false if work was already idle\n */\nbool k_work_flush(struct k_work *work,\n\t\t  struct k_work_sync *sync);\n\n/** @brief Cancel a work item.\n *\n * This attempts to prevent a pending (non-delayable) work item from being\n * processed by removing it from the work queue.  If the item is being\n * processed, the work item will continue to be processed, but resubmissions\n * are rejected until cancellation completes.\n *\n * If this returns zero cancellation is complete, otherwise something\n * (probably a work queue thread) is still referencing the item.\n *\n * See also k_work_cancel_sync().\n *\n * @funcprops \\isr_ok\n *\n * @param work pointer to the work item.\n *\n * @return the k_work_busy_get() status indicating the state of the item after all\n * cancellation steps performed by this call are completed.\n */\nint k_work_cancel(struct k_work *work);\n\n/** @brief Cancel a work item and wait for it to complete.\n *\n * Same as k_work_cancel() but does not return until cancellation is complete.\n * This can be invoked by a thread after k_work_cancel() to synchronize with a\n * previous cancellation.\n *\n * On return the work structure will be idle unless something submits it after\n * the cancellation was complete.\n *\n * @note Be careful of caller and work queue thread relative priority.  If\n * this function sleeps it will not return until the work queue thread\n * completes the tasks that allow this thread to resume.\n *\n * @note Behavior is undefined if this function is invoked on @p work from a\n * work queue running @p work.\n *\n * @param work pointer to the work item.\n *\n * @param sync pointer to an opaque item containing state related to the\n * pending cancellation.  The object must persist until the call returns, and\n * be accessible from both the caller thread and the work queue thread.  The\n * object must not be used for any other flush or cancel operation until this\n * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n * must be allocated in coherent memory.\n *\n * @retval true if work was pending (call had to wait for cancellation of a\n * running handler to complete, or scheduled or submitted operations were\n * cancelled);\n * @retval false otherwise\n */\nbool k_work_cancel_sync(struct k_work *work, struct k_work_sync *sync);\n\n/** @brief Initialize a work queue structure.\n *\n * This must be invoked before starting a work queue structure for the first time.\n * It need not be invoked again on the same work queue structure.\n *\n * @funcprops \\isr_ok\n *\n * @param queue the queue structure to be initialized.\n */\nvoid k_work_queue_init(struct k_work_q *queue);\n\n/** @brief Initialize a work queue.\n *\n * This configures the work queue thread and starts it running.  The function\n * should not be re-invoked on a queue.\n *\n * @param queue pointer to the queue structure. It must be initialized\n *        in zeroed/bss memory or with @ref k_work_queue_init before\n *        use.\n *\n * @param stack pointer to the work thread stack area.\n *\n * @param stack_size size of the work thread stack area, in bytes.\n *\n * @param prio initial thread priority\n *\n * @param cfg optional additional configuration parameters.  Pass @c\n * NULL if not required, to use the defaults documented in\n * k_work_queue_config.\n */\nvoid k_work_queue_start(struct k_work_q *queue,\n\t\t\tk_thread_stack_t *stack, size_t stack_size,\n\t\t\tint prio, const struct k_work_queue_config *cfg);\n\n/** @brief Access the thread that animates a work queue.\n *\n * This is necessary to grant a work queue thread access to things the work\n * items it will process are expected to use.\n *\n * @param queue pointer to the queue structure.\n *\n * @return the thread associated with the work queue.\n */\nstatic inline k_tid_t k_work_queue_thread_get(struct k_work_q *queue);\n\n/** @brief Wait until the work queue has drained, optionally plugging it.\n *\n * This blocks submission to the work queue except when coming from queue\n * thread, and blocks the caller until no more work items are available in the\n * queue.\n *\n * If @p plug is true then submission will continue to be blocked after the\n * drain operation completes until k_work_queue_unplug() is invoked.\n *\n * Note that work items that are delayed are not yet associated with their\n * work queue.  They must be cancelled externally if a goal is to ensure the\n * work queue remains empty.  The @p plug feature can be used to prevent\n * delayed items from being submitted after the drain completes.\n *\n * @param queue pointer to the queue structure.\n *\n * @param plug if true the work queue will continue to block new submissions\n * after all items have drained.\n *\n * @retval 1 if call had to wait for the drain to complete\n * @retval 0 if call did not have to wait\n * @retval negative if wait was interrupted or failed\n */\nint k_work_queue_drain(struct k_work_q *queue, bool plug);\n\n/** @brief Release a work queue to accept new submissions.\n *\n * This releases the block on new submissions placed when k_work_queue_drain()\n * is invoked with the @p plug option enabled.  If this is invoked before the\n * drain completes new items may be submitted as soon as the drain completes.\n *\n * @funcprops \\isr_ok\n *\n * @param queue pointer to the queue structure.\n *\n * @retval 0 if successfully unplugged\n * @retval -EALREADY if the work queue was not plugged.\n */\nint k_work_queue_unplug(struct k_work_q *queue);\n\n/** @brief Stop a work queue.\n *\n * Stops the work queue thread and ensures that no further work will be processed.\n * This call is blocking and guarantees that the work queue thread has terminated\n * cleanly if successful, no work will be processed past this point.\n *\n * @param queue Pointer to the queue structure.\n * @param timeout Maximum time to wait for the work queue to stop.\n *\n * @retval 0 if the work queue was stopped\n * @retval -EALREADY if the work queue was not started (or already stopped)\n * @retval -EBUSY if the work queue is actively processing work items\n * @retval -ETIMEDOUT if the work queue did not stop within the stipulated timeout\n */\nint k_work_queue_stop(struct k_work_q *queue, k_timeout_t timeout);\n\n/** @brief Initialize a delayable work structure.\n *\n * This must be invoked before scheduling a delayable work structure for the\n * first time.  It need not be invoked again on the same work structure.  It\n * can be re-invoked to change the associated handler, but this must be done\n * when the work item is idle.\n *\n * @funcprops \\isr_ok\n *\n * @param dwork the delayable work structure to be initialized.\n *\n * @param handler the handler to be invoked by the work item.\n */\nvoid k_work_init_delayable(struct k_work_delayable *dwork,\n\t\t\t   k_work_handler_t handler);\n\n/**\n * @brief Get the parent delayable work structure from a work pointer.\n *\n * This function is necessary when a @c k_work_handler_t function is passed to\n * k_work_schedule_for_queue() and the handler needs to access data from the\n * container of the containing `k_work_delayable`.\n *\n * @param work Address passed to the work handler\n *\n * @return Address of the containing @c k_work_delayable structure.\n */\nstatic inline struct k_work_delayable *\nk_work_delayable_from_work(struct k_work *work);\n\n/** @brief Busy state flags from the delayable work item.\n *\n * @funcprops \\isr_ok\n *\n * @note This is a live snapshot of state, which may change before the result\n * can be inspected.  Use locks where appropriate.\n *\n * @param dwork pointer to the delayable work item.\n *\n * @return a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING,\n * K_WORK_CANCELING, and K_WORK_FLUSHING.  A zero return value indicates the\n * work item appears to be idle.\n */\nint k_work_delayable_busy_get(const struct k_work_delayable *dwork);\n\n/** @brief Test whether a delayed work item is currently pending.\n *\n * Wrapper to determine whether a delayed work item is in a non-idle state.\n *\n * @note This is a live snapshot of state, which may change before the result\n * can be inspected.  Use locks where appropriate.\n *\n * @funcprops \\isr_ok\n *\n * @param dwork pointer to the delayable work item.\n *\n * @return true if and only if k_work_delayable_busy_get() returns a non-zero\n * value.\n */\nstatic inline bool k_work_delayable_is_pending(\n\tconst struct k_work_delayable *dwork);\n\n/** @brief Get the absolute tick count at which a scheduled delayable work\n * will be submitted.\n *\n * @note This is a live snapshot of state, which may change before the result\n * can be inspected.  Use locks where appropriate.\n *\n * @funcprops \\isr_ok\n *\n * @param dwork pointer to the delayable work item.\n *\n * @return the tick count when the timer that will schedule the work item will\n * expire, or the current tick count if the work is not scheduled.\n */\nstatic inline k_ticks_t k_work_delayable_expires_get(\n\tconst struct k_work_delayable *dwork);\n\n/** @brief Get the number of ticks until a scheduled delayable work will be\n * submitted.\n *\n * @note This is a live snapshot of state, which may change before the result\n * can be inspected.  Use locks where appropriate.\n *\n * @funcprops \\isr_ok\n *\n * @param dwork pointer to the delayable work item.\n *\n * @return the number of ticks until the timer that will schedule the work\n * item will expire, or zero if the item is not scheduled.\n */\nstatic inline k_ticks_t k_work_delayable_remaining_get(\n\tconst struct k_work_delayable *dwork);\n\n/** @brief Submit an idle work item to a queue after a delay.\n *\n * Unlike k_work_reschedule_for_queue() this is a no-op if the work item is\n * already scheduled or submitted, even if @p delay is @c K_NO_WAIT.\n *\n * @funcprops \\isr_ok\n *\n * @param queue the queue on which the work item should be submitted after the\n * delay.\n *\n * @param dwork pointer to the delayable work item.\n *\n * @param delay the time to wait before submitting the work item.  If @c\n * K_NO_WAIT and the work is not pending this is equivalent to\n * k_work_submit_to_queue().\n *\n * @retval 0 if work was already scheduled or submitted.\n * @retval 1 if work has been scheduled.\n * @retval 2 if @p delay is @c K_NO_WAIT and work\n *         was running and has been queued to the queue that was running it.\n * @retval -EBUSY if @p delay is @c K_NO_WAIT and\n *         k_work_submit_to_queue() fails with this code.\n * @retval -EINVAL if @p delay is @c K_NO_WAIT and\n *         k_work_submit_to_queue() fails with this code.\n * @retval -ENODEV if @p delay is @c K_NO_WAIT and\n *         k_work_submit_to_queue() fails with this code.\n */\nint k_work_schedule_for_queue(struct k_work_q *queue,\n\t\t\t       struct k_work_delayable *dwork,\n\t\t\t       k_timeout_t delay);\n\n/** @brief Submit an idle work item to the system work queue after a\n * delay.\n *\n * This is a thin wrapper around k_work_schedule_for_queue(), with all the API\n * characteristics of that function.\n *\n * @param dwork pointer to the delayable work item.\n *\n * @param delay the time to wait before submitting the work item.  If @c\n * K_NO_WAIT this is equivalent to k_work_submit_to_queue().\n *\n * @return as with k_work_schedule_for_queue().\n */\nint k_work_schedule(struct k_work_delayable *dwork,\n\t\t\t\t   k_timeout_t delay);\n\n/** @brief Reschedule a work item to a queue after a delay.\n *\n * Unlike k_work_schedule_for_queue() this function can change the deadline of\n * a scheduled work item, and will schedule a work item that is in any state\n * (e.g. is idle, submitted, or running).  This function does not affect\n * (&quot;unsubmit&quot;) a work item that has been submitted to a queue.\n *\n * @funcprops \\isr_ok\n *\n * @param queue the queue on which the work item should be submitted after the\n * delay.\n *\n * @param dwork pointer to the delayable work item.\n *\n * @param delay the time to wait before submitting the work item.  If @c\n * K_NO_WAIT this is equivalent to k_work_submit_to_queue() after canceling\n * any previous scheduled submission.\n *\n * @note If delay is @c K_NO_WAIT (&quot;no delay&quot;) the return values are as with\n * k_work_submit_to_queue().\n *\n * @retval 0 if delay is @c K_NO_WAIT and work was already on a queue\n * @retval 1 if\n * * delay is @c K_NO_WAIT and work was not submitted but has now been queued\n *   to @p queue; or\n * * delay not @c K_NO_WAIT and work has been scheduled\n * @retval 2 if delay is @c K_NO_WAIT and work was running and has been queued\n * to the queue that was running it\n * @retval -EBUSY if @p delay is @c K_NO_WAIT and\n *         k_work_submit_to_queue() fails with this code.\n * @retval -EINVAL if @p delay is @c K_NO_WAIT and\n *         k_work_submit_to_queue() fails with this code.\n * @retval -ENODEV if @p delay is @c K_NO_WAIT and\n *         k_work_submit_to_queue() fails with this code.\n */\nint k_work_reschedule_for_queue(struct k_work_q *queue,\n\t\t\t\t struct k_work_delayable *dwork,\n\t\t\t\t k_timeout_t delay);\n\n/** @brief Reschedule a work item to the system work queue after a\n * delay.\n *\n * This is a thin wrapper around k_work_reschedule_for_queue(), with all the\n * API characteristics of that function.\n *\n * @param dwork pointer to the delayable work item.\n *\n * @param delay the time to wait before submitting the work item.\n *\n * @return as with k_work_reschedule_for_queue().\n */\nint k_work_reschedule(struct k_work_delayable *dwork,\n\t\t\t\t     k_timeout_t delay);\n\n/** @brief Flush delayable work.\n *\n * If the work is scheduled, it is immediately submitted.  Then the caller\n * blocks until the work completes, as with k_work_flush().\n *\n * @note Be careful of caller and work queue thread relative priority.  If\n * this function sleeps it will not return until the work queue thread\n * completes the tasks that allow this thread to resume.\n *\n * @note Behavior is undefined if this function is invoked on @p dwork from a\n * work queue running @p dwork.\n *\n * @param dwork pointer to the delayable work item.\n *\n * @param sync pointer to an opaque item containing state related to the\n * pending cancellation.  The object must persist until the call returns, and\n * be accessible from both the caller thread and the work queue thread.  The\n * object must not be used for any other flush or cancel operation until this\n * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n * must be allocated in coherent memory.\n *\n * @retval true if call had to wait for completion\n * @retval false if work was already idle\n */\nbool k_work_flush_delayable(struct k_work_delayable *dwork,\n\t\t\t    struct k_work_sync *sync);\n\n/** @brief Cancel delayable work.\n *\n * Similar to k_work_cancel() but for delayable work.  If the work is\n * scheduled or submitted it is canceled.  This function does not wait for the\n * cancellation to complete.\n *\n * @note The work may still be running when this returns.  Use\n * k_work_flush_delayable() or k_work_cancel_delayable_sync() to ensure it is\n * not running.\n *\n * @note Canceling delayable work does not prevent rescheduling it.  It does\n * prevent submitting it until the cancellation completes.\n *\n * @funcprops \\isr_ok\n *\n * @param dwork pointer to the delayable work item.\n *\n * @return the k_work_delayable_busy_get() status indicating the state of the\n * item after all cancellation steps performed by this call are completed.\n */\nint k_work_cancel_delayable(struct k_work_delayable *dwork);\n\n/** @brief Cancel delayable work and wait.\n *\n * Like k_work_cancel_delayable() but waits until the work becomes idle.\n *\n * @note Canceling delayable work does not prevent rescheduling it.  It does\n * prevent submitting it until the cancellation completes.\n *\n * @note Be careful of caller and work queue thread relative priority.  If\n * this function sleeps it will not return until the work queue thread\n * completes the tasks that allow this thread to resume.\n *\n * @note Behavior is undefined if this function is invoked on @p dwork from a\n * work queue running @p dwork.\n *\n * @param dwork pointer to the delayable work item.\n *\n * @param sync pointer to an opaque item containing state related to the\n * pending cancellation.  The object must persist until the call returns, and\n * be accessible from both the caller thread and the work queue thread.  The\n * object must not be used for any other flush or cancel operation until this\n * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n * must be allocated in coherent memory.\n *\n * @retval true if work was not idle (call had to wait for cancellation of a\n * running handler to complete, or scheduled or submitted operations were\n * cancelled);\n * @retval false otherwise\n */\nbool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,\n\t\t\t\t  struct k_work_sync *sync);\n\nenum {\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n\t/* The atomic API is used for all work and queue flags fields to\n\t * enforce sequential consistency in SMP environments.\n\t */\n\n\t/* Bits that represent the work item states.  At least nine of the\n\t * combinations are distinct valid stable states.\n\t */\n\tK_WORK_RUNNING_BIT = 0,\n\tK_WORK_CANCELING_BIT = 1,\n\tK_WORK_QUEUED_BIT = 2,\n\tK_WORK_DELAYED_BIT = 3,\n\tK_WORK_FLUSHING_BIT = 4,\n\n\tK_WORK_MASK = BIT(K_WORK_DELAYED_BIT) | BIT(K_WORK_QUEUED_BIT)\n\t\t| BIT(K_WORK_RUNNING_BIT) | BIT(K_WORK_CANCELING_BIT) | BIT(K_WORK_FLUSHING_BIT),\n\n\t/* Static work flags */\n\tK_WORK_DELAYABLE_BIT = 8,\n\tK_WORK_DELAYABLE = BIT(K_WORK_DELAYABLE_BIT),\n\n\t/* Dynamic work queue flags */\n\tK_WORK_QUEUE_STARTED_BIT = 0,\n\tK_WORK_QUEUE_STARTED = BIT(K_WORK_QUEUE_STARTED_BIT),\n\tK_WORK_QUEUE_BUSY_BIT = 1,\n\tK_WORK_QUEUE_BUSY = BIT(K_WORK_QUEUE_BUSY_BIT),\n\tK_WORK_QUEUE_DRAIN_BIT = 2,\n\tK_WORK_QUEUE_DRAIN = BIT(K_WORK_QUEUE_DRAIN_BIT),\n\tK_WORK_QUEUE_PLUGGED_BIT = 3,\n\tK_WORK_QUEUE_PLUGGED = BIT(K_WORK_QUEUE_PLUGGED_BIT),\n\tK_WORK_QUEUE_STOP_BIT = 4,\n\tK_WORK_QUEUE_STOP = BIT(K_WORK_QUEUE_STOP_BIT),\n\n\t/* Static work queue flags */\n\tK_WORK_QUEUE_NO_YIELD_BIT = 8,\n\tK_WORK_QUEUE_NO_YIELD = BIT(K_WORK_QUEUE_NO_YIELD_BIT),\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\t/* Transient work flags */\n\n\t/** @brief Flag indicating a work item that is running under a work\n\t * queue thread.\n\t *\n\t * Accessed via k_work_busy_get().  May co-occur with other flags.\n\t */\n\tK_WORK_RUNNING = BIT(K_WORK_RUNNING_BIT),\n\n\t/** @brief Flag indicating a work item that is being canceled.\n\t *\n\t * Accessed via k_work_busy_get().  May co-occur with other flags.\n\t */\n\tK_WORK_CANCELING = BIT(K_WORK_CANCELING_BIT),\n\n\t/** @brief Flag indicating a work item that has been submitted to a\n\t * queue but has not started running.\n\t *\n\t * Accessed via k_work_busy_get().  May co-occur with other flags.\n\t */\n\tK_WORK_QUEUED = BIT(K_WORK_QUEUED_BIT),\n\n\t/** @brief Flag indicating a delayed work item that is scheduled for\n\t * submission to a queue.\n\t *\n\t * Accessed via k_work_busy_get().  May co-occur with other flags.\n\t */\n\tK_WORK_DELAYED = BIT(K_WORK_DELAYED_BIT),\n\n\t/** @brief Flag indicating a synced work item that is being flushed.\n\t *\n\t * Accessed via k_work_busy_get().  May co-occur with other flags.\n\t */\n\tK_WORK_FLUSHING = BIT(K_WORK_FLUSHING_BIT),\n};\n\n/** @brief A structure used to submit work. */\nstruct k_work {\n\t/* All fields are protected by the work module spinlock.  No fields\n\t * are to be accessed except through kernel API.\n\t */\n\n\t/* Node to link into k_work_q pending list. */\n\tsys_snode_t node;\n\n\t/* The function to be invoked by the work queue thread. */\n\tk_work_handler_t handler;\n\n\t/* The queue on which the work item was last submitted. */\n\tstruct k_work_q *queue;\n\n\t/* State of the work item.\n\t *\n\t * The item can be DELAYED, QUEUED, and RUNNING simultaneously.\n\t *\n\t * It can be RUNNING and CANCELING simultaneously.\n\t */\n\tuint32_t flags;\n};\n\n#define Z_WORK_INITIALIZER(work_handler) { \\\n\t.handler = (work_handler), \\\n}\n\n/** @brief A structure used to submit work after a delay. */\nstruct k_work_delayable {\n\t/* The work item. */\n\tstruct k_work work;\n\n\t/* Timeout used to submit work after a delay. */\n\tstruct _timeout timeout;\n\n\t/* The queue to which the work should be submitted. */\n\tstruct k_work_q *queue;\n};\n\n#define Z_WORK_DELAYABLE_INITIALIZER(work_handler) { \\\n\t.work = { \\\n\t\t.handler = (work_handler), \\\n\t\t.flags = K_WORK_DELAYABLE, \\\n\t}, \\\n}\n\n/**\n * @brief Initialize a statically-defined delayable work item.\n *\n * This macro can be used to initialize a statically-defined delayable\n * work item, prior to its first use. For example,\n *\n * @code static K_WORK_DELAYABLE_DEFINE(&lt;dwork&gt;, &lt;work_handler&gt;); @endcode\n *\n * Note that if the runtime dependencies support initialization with\n * k_work_init_delayable() using that will eliminate the initialized\n * object in ROM that is produced by this macro and copied in at\n * system startup.\n *\n * @param work Symbol name for delayable work item object\n * @param work_handler Function to invoke each time work item is processed.\n */\n#define K_WORK_DELAYABLE_DEFINE(work, work_handler) \\\n\tstruct k_work_delayable work \\\n\t  = Z_WORK_DELAYABLE_INITIALIZER(work_handler)\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n/* Record used to wait for work to flush.\n *\n * The work item is inserted into the queue that will process (or is\n * processing) the item, and will be processed as soon as the item\n * completes.  When the flusher is processed the semaphore will be\n * signaled, releasing the thread waiting for the flush.\n */\nstruct z_work_flusher {\n\tstruct k_work work;\n\tstruct k_sem sem;\n};\n\n/* Record used to wait for work to complete a cancellation.\n *\n * The work item is inserted into a global queue of pending cancels.\n * When a cancelling work item goes idle any matching waiters are\n * removed from pending_cancels and are woken.\n */\nstruct z_work_canceller {\n\tsys_snode_t node;\n\tstruct k_work *work;\n\tstruct k_sem sem;\n};\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/** @brief A structure holding internal state for a pending synchronous\n * operation on a work item or queue.\n *\n * Instances of this type are provided by the caller for invocation of\n * k_work_flush(), k_work_cancel_sync() and sibling flush and cancel APIs.  A\n * referenced object must persist until the call returns, and be accessible\n * from both the caller thread and the work queue thread.\n *\n * @note If CONFIG_KERNEL_COHERENCE is enabled the object must be allocated in\n * coherent memory; see arch_mem_coherent().  The stack on these architectures\n * is generally not coherent.  be stack-allocated.  Violations are detected by\n * runtime assertion.\n */\nstruct k_work_sync {\n\tunion {\n\t\tstruct z_work_flusher flusher;\n\t\tstruct z_work_canceller canceller;\n\t};\n};\n\n/** @brief A structure holding optional configuration items for a work\n * queue.\n *\n * This structure, and values it references, are not retained by\n * k_work_queue_start().\n */\nstruct k_work_queue_config {\n\t/** The name to be given to the work queue thread.\n\t *\n\t * If left null the thread will not have a name.\n\t */\n\tconst char *name;\n\n\t/** Control whether the work queue thread should yield between\n\t * items.\n\t *\n\t * Yielding between items helps guarantee the work queue\n\t * thread does not starve other threads, including cooperative\n\t * ones released by a work item.  This is the default behavior.\n\t *\n\t * Set this to @c true to prevent the work queue thread from\n\t * yielding between items.  This may be appropriate when a\n\t * sequence of items should complete without yielding\n\t * control.\n\t */\n\tbool no_yield;\n\n\t/** Control whether the work queue thread should be marked as\n\t * essential thread.\n\t */\n\tbool essential;\n};\n\n/** @brief A structure used to hold work until it can be processed. */\nstruct k_work_q {\n\t/* The thread that animates the work. */\n\tstruct k_thread thread;\n\n\t/* All the following fields must be accessed only while the\n\t * work module spinlock is held.\n\t */\n\n\t/* List of k_work items to be worked. */\n\tsys_slist_t pending;\n\n\t/* Wait queue for idle work thread. */\n\t_wait_q_t notifyq;\n\n\t/* Wait queue for threads waiting for the queue to drain. */\n\t_wait_q_t drainq;\n\n\t/* Flags describing queue state. */\n\tuint32_t flags;\n};\n\n/* Provide the implementation for inline functions declared above */\n\nstatic inline bool k_work_is_pending(const struct k_work *work)\n{\n\treturn k_work_busy_get(work) != 0;\n}\n\nstatic inline struct k_work_delayable *\nk_work_delayable_from_work(struct k_work *work)\n{\n\treturn CONTAINER_OF(work, struct k_work_delayable, work);\n}\n\nstatic inline bool k_work_delayable_is_pending(\n\tconst struct k_work_delayable *dwork)\n{\n\treturn k_work_delayable_busy_get(dwork) != 0;\n}\n\nstatic inline k_ticks_t k_work_delayable_expires_get(\n\tconst struct k_work_delayable *dwork)\n{\n\treturn z_timeout_expires(&amp;dwork-&gt;timeout);\n}\n\nstatic inline k_ticks_t k_work_delayable_remaining_get(\n\tconst struct k_work_delayable *dwork)\n{\n\treturn z_timeout_remaining(&amp;dwork-&gt;timeout);\n}\n\nstatic inline k_tid_t k_work_queue_thread_get(struct k_work_q *queue)\n{\n\treturn &amp;queue-&gt;thread;\n}\n\n/** @} */\n\nstruct k_work_user;\n\n/**\n * @addtogroup workqueue_apis\n * @{\n */\n\n/**\n * @typedef k_work_user_handler_t\n * @brief Work item handler function type for user work queues.\n *\n * A work item&#x27;s handler function is executed by a user workqueue&#x27;s thread\n * when the work item is processed by the workqueue.\n *\n * @param work Address of the work item.\n */\ntypedef void (*k_work_user_handler_t)(struct k_work_user *work);\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\nstruct k_work_user_q {\n\tstruct k_queue queue;\n\tstruct k_thread thread;\n};\n\nenum {\n\tK_WORK_USER_STATE_PENDING,\t/* Work item pending state */\n};\n\nstruct k_work_user {\n\tvoid *_reserved;\t\t/* Used by k_queue implementation. */\n\tk_work_user_handler_t handler;\n\tatomic_t flags;\n};\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n#if defined(__cplusplus) &amp;&amp; ((__cplusplus - 0) &lt; 202002L)\n#define Z_WORK_USER_INITIALIZER(work_handler) { NULL, work_handler, 0 }\n#else\n#define Z_WORK_USER_INITIALIZER(work_handler) \\\n\t{ \\\n\t._reserved = NULL, \\\n\t.handler = (work_handler), \\\n\t.flags = 0 \\\n\t}\n#endif\n\n/**\n * @brief Initialize a statically-defined user work item.\n *\n * This macro can be used to initialize a statically-defined user work\n * item, prior to its first use. For example,\n *\n * @code static K_WORK_USER_DEFINE(&lt;work&gt;, &lt;work_handler&gt;); @endcode\n *\n * @param work Symbol name for work item object\n * @param work_handler Function to invoke each time work item is processed.\n */\n#define K_WORK_USER_DEFINE(work, work_handler) \\\n\tstruct k_work_user work = Z_WORK_USER_INITIALIZER(work_handler)\n\n/**\n * @brief Initialize a userspace work item.\n *\n * This routine initializes a user workqueue work item, prior to its\n * first use.\n *\n * @param work Address of work item.\n * @param handler Function to invoke each time work item is processed.\n */\nstatic inline void k_work_user_init(struct k_work_user *work,\n\t\t\t\t    k_work_user_handler_t handler)\n{\n\t*work = (struct k_work_user)Z_WORK_USER_INITIALIZER(handler);\n}\n\n/**\n * @brief Check if a userspace work item is pending.\n *\n * This routine indicates if user work item @a work is pending in a workqueue&#x27;s\n * queue.\n *\n * @note Checking if the work is pending gives no guarantee that the\n *       work will still be pending when this information is used. It is up to\n *       the caller to make sure that this information is used in a safe manner.\n *\n * @funcprops \\isr_ok\n *\n * @param work Address of work item.\n *\n * @return true if work item is pending, or false if it is not pending.\n */\nstatic inline bool k_work_user_is_pending(struct k_work_user *work)\n{\n\treturn atomic_test_bit(&amp;work-&gt;flags, K_WORK_USER_STATE_PENDING);\n}\n\n/**\n * @brief Submit a work item to a user mode workqueue\n *\n * Submits a work item to a workqueue that runs in user mode. A temporary\n * memory allocation is made from the caller&#x27;s resource pool which is freed\n * once the worker thread consumes the k_work item. The workqueue\n * thread must have memory access to the k_work item being submitted. The caller\n * must have permission granted on the work_q parameter&#x27;s queue object.\n *\n * @funcprops \\isr_ok\n *\n * @param work_q Address of workqueue.\n * @param work Address of work item.\n *\n * @retval -EBUSY if the work item was already in some workqueue\n * @retval -ENOMEM if no memory for thread resource pool allocation\n * @retval 0 Success\n */\nstatic inline int k_work_user_submit_to_queue(struct k_work_user_q *work_q,\n\t\t\t\t\t      struct k_work_user *work)\n{\n\tint ret = -EBUSY;\n\n\tif (!atomic_test_and_set_bit(&amp;work-&gt;flags,\n\t\t\t\t     K_WORK_USER_STATE_PENDING)) {\n\t\tret = k_queue_alloc_append(&amp;work_q-&gt;queue, work);\n\n\t\t/* Couldn&#x27;t insert into the queue. Clear the pending bit\n\t\t * so the work item can be submitted again\n\t\t */\n\t\tif (ret != 0) {\n\t\t\tatomic_clear_bit(&amp;work-&gt;flags,\n\t\t\t\t\t K_WORK_USER_STATE_PENDING);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/**\n * @brief Start a workqueue in user mode\n *\n * This works identically to k_work_queue_start() except it is callable from\n * user mode, and the worker thread created will run in user mode.  The caller\n * must have permissions granted on both the work_q parameter&#x27;s thread and\n * queue objects, and the same restrictions on priority apply as\n * k_thread_create().\n *\n * @param work_q Address of workqueue.\n * @param stack Pointer to work queue thread&#x27;s stack space, as defined by\n *\t\tK_THREAD_STACK_DEFINE()\n * @param stack_size Size of the work queue thread&#x27;s stack (in bytes), which\n *\t\tshould either be the same constant passed to\n *\t\tK_THREAD_STACK_DEFINE() or the value of K_THREAD_STACK_SIZEOF().\n * @param prio Priority of the work queue&#x27;s thread.\n * @param name optional thread name.  If not null a copy is made into the\n *\t\tthread&#x27;s name buffer.\n */\nvoid k_work_user_queue_start(struct k_work_user_q *work_q,\n\t\t\t\t    k_thread_stack_t *stack,\n\t\t\t\t    size_t stack_size, int prio,\n\t\t\t\t    const char *name);\n\n/**\n * @brief Access the user mode thread that animates a work queue.\n *\n * This is necessary to grant a user mode work queue thread access to things\n * the work items it will process are expected to use.\n *\n * @param work_q pointer to the user mode queue structure.\n *\n * @return the user mode thread associated with the work queue.\n */\nstatic inline k_tid_t k_work_user_queue_thread_get(struct k_work_user_q *work_q)\n{\n\treturn &amp;work_q-&gt;thread;\n}\n\n/** @} */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\nstruct k_work_poll {\n\tstruct k_work work;\n\tstruct k_work_q *workq;\n\tstruct z_poller poller;\n\tstruct k_poll_event *events;\n\tint num_events;\n\tk_work_handler_t real_handler;\n\tstruct _timeout timeout;\n\tint poll_result;\n};\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @addtogroup workqueue_apis\n * @{\n */\n\n/**\n * @brief Initialize a statically-defined work item.\n *\n * This macro can be used to initialize a statically-defined workqueue work\n * item, prior to its first use. For example,\n *\n * @code static K_WORK_DEFINE(&lt;work&gt;, &lt;work_handler&gt;); @endcode\n *\n * @param work Symbol name for work item object\n * @param work_handler Function to invoke each time work item is processed.\n */\n#define K_WORK_DEFINE(work, work_handler) \\\n\tstruct k_work work = Z_WORK_INITIALIZER(work_handler)\n\n/**\n * @brief Initialize a triggered work item.\n *\n * This routine initializes a workqueue triggered work item, prior to\n * its first use.\n *\n * @param work Address of triggered work item.\n * @param handler Function to invoke each time work item is processed.\n */\nvoid k_work_poll_init(struct k_work_poll *work,\n\t\t\t     k_work_handler_t handler);\n\n/**\n * @brief Submit a triggered work item.\n *\n * This routine schedules work item @a work to be processed by workqueue\n * @a work_q when one of the given @a events is signaled. The routine\n * initiates internal poller for the work item and then returns to the caller.\n * Only when one of the watched events happen the work item is actually\n * submitted to the workqueue and becomes pending.\n *\n * Submitting a previously submitted triggered work item that is still\n * waiting for the event cancels the existing submission and reschedules it\n * the using the new event list. Note that this behavior is inherently subject\n * to race conditions with the pre-existing triggered work item and work queue,\n * so care must be taken to synchronize such resubmissions externally.\n *\n * @funcprops \\isr_ok\n *\n * @warning\n * Provided array of events as well as a triggered work item must be placed\n * in persistent memory (valid until work handler execution or work\n * cancellation) and cannot be modified after submission.\n *\n * @param work_q Address of workqueue.\n * @param work Address of delayed work item.\n * @param events An array of events which trigger the work.\n * @param num_events The number of events in the array.\n * @param timeout Timeout after which the work will be scheduled\n *\t\t  for execution even if not triggered.\n *\n *\n * @retval 0 Work item started watching for events.\n * @retval -EINVAL Work item is being processed or has completed its work.\n * @retval -EADDRINUSE Work item is pending on a different workqueue.\n */\nint k_work_poll_submit_to_queue(struct k_work_q *work_q,\n\t\t\t\t       struct k_work_poll *work,\n\t\t\t\t       struct k_poll_event *events,\n\t\t\t\t       int num_events,\n\t\t\t\t       k_timeout_t timeout);\n\n/**\n * @brief Submit a triggered work item to the system workqueue.\n *\n * This routine schedules work item @a work to be processed by system\n * workqueue when one of the given @a events is signaled. The routine\n * initiates internal poller for the work item and then returns to the caller.\n * Only when one of the watched events happen the work item is actually\n * submitted to the workqueue and becomes pending.\n *\n * Submitting a previously submitted triggered work item that is still\n * waiting for the event cancels the existing submission and reschedules it\n * the using the new event list. Note that this behavior is inherently subject\n * to race conditions with the pre-existing triggered work item and work queue,\n * so care must be taken to synchronize such resubmissions externally.\n *\n * @funcprops \\isr_ok\n *\n * @warning\n * Provided array of events as well as a triggered work item must not be\n * modified until the item has been processed by the workqueue.\n *\n * @param work Address of delayed work item.\n * @param events An array of events which trigger the work.\n * @param num_events The number of events in the array.\n * @param timeout Timeout after which the work will be scheduled\n *\t\t  for execution even if not triggered.\n *\n * @retval 0 Work item started watching for events.\n * @retval -EINVAL Work item is being processed or has completed its work.\n * @retval -EADDRINUSE Work item is pending on a different workqueue.\n */\nint k_work_poll_submit(struct k_work_poll *work,\n\t\t\t\t     struct k_poll_event *events,\n\t\t\t\t     int num_events,\n\t\t\t\t     k_timeout_t timeout);\n\n/**\n * @brief Cancel a triggered work item.\n *\n * This routine cancels the submission of triggered work item @a work.\n * A triggered work item can only be canceled if no event triggered work\n * submission.\n *\n * @funcprops \\isr_ok\n *\n * @param work Address of delayed work item.\n *\n * @retval 0 Work item canceled.\n * @retval -EINVAL Work item is being processed or has completed its work.\n */\nint k_work_poll_cancel(struct k_work_poll *work);\n\n/** @} */\n\n/**\n * @defgroup msgq_apis Message Queue APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Message Queue Structure\n */\nstruct k_msgq {\n\t/** Message queue wait queue */\n\t_wait_q_t wait_q;\n\t/** Lock */\n\tstruct k_spinlock lock;\n\t/** Message size */\n\tsize_t msg_size;\n\t/** Maximal number of messages */\n\tuint32_t max_msgs;\n\t/** Start of message buffer */\n\tchar *buffer_start;\n\t/** End of message buffer */\n\tchar *buffer_end;\n\t/** Read pointer */\n\tchar *read_ptr;\n\t/** Write pointer */\n\tchar *write_ptr;\n\t/** Number of used messages */\n\tuint32_t used_msgs;\n\n\tZ_DECL_POLL_EVENT\n\n\t/** Message queue */\n\tuint8_t flags;\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_msgq)\n\n#ifdef CONFIG_OBJ_CORE_MSGQ\n\tstruct k_obj_core  obj_core;\n#endif\n};\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n\n#define Z_MSGQ_INITIALIZER(obj, q_buffer, q_msg_size, q_max_msgs) \\\n\t{ \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;obj.wait_q), \\\n\t.msg_size = q_msg_size, \\\n\t.max_msgs = q_max_msgs, \\\n\t.buffer_start = q_buffer, \\\n\t.buffer_end = q_buffer + (q_max_msgs * q_msg_size), \\\n\t.read_ptr = q_buffer, \\\n\t.write_ptr = q_buffer, \\\n\t.used_msgs = 0, \\\n\tZ_POLL_EVENT_OBJ_INIT(obj) \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n\n#define K_MSGQ_FLAG_ALLOC\tBIT(0)\n\n/**\n * @brief Message Queue Attributes\n */\nstruct k_msgq_attrs {\n\t/** Message Size */\n\tsize_t msg_size;\n\t/** Maximal number of messages */\n\tuint32_t max_msgs;\n\t/** Used messages */\n\tuint32_t used_msgs;\n};\n\n\n/**\n * @brief Statically define and initialize a message queue.\n *\n * The message queue&#x27;s ring buffer contains space for @a q_max_msgs messages,\n * each of which is @a q_msg_size bytes long. Alignment of the message queue&#x27;s\n * ring buffer is not necessary, setting @a q_align to 1 is sufficient.\n *\n * The message queue can be accessed outside the module where it is defined\n * using:\n *\n * @code extern struct k_msgq &lt;name&gt;; @endcode\n *\n * @param q_name Name of the message queue.\n * @param q_msg_size Message size (in bytes).\n * @param q_max_msgs Maximum number of messages that can be queued.\n * @param q_align Alignment of the message queue&#x27;s ring buffer (power of 2).\n *\n */\n#define K_MSGQ_DEFINE(q_name, q_msg_size, q_max_msgs, q_align)\t\t\\\n\tstatic char __noinit __aligned(q_align)\t\t\t\t\\\n\t\t_k_fifo_buf_##q_name[(q_max_msgs) * (q_msg_size)];\t\\\n\tSTRUCT_SECTION_ITERABLE(k_msgq, q_name) =\t\t\t\\\n\t       Z_MSGQ_INITIALIZER(q_name, _k_fifo_buf_##q_name,\t\\\n\t\t\t\t  (q_msg_size), (q_max_msgs))\n\n/**\n * @brief Initialize a message queue.\n *\n * This routine initializes a message queue object, prior to its first use.\n *\n * The message queue&#x27;s ring buffer must contain space for @a max_msgs messages,\n * each of which is @a msg_size bytes long. Alignment of the message queue&#x27;s\n * ring buffer is not necessary.\n *\n * @param msgq Address of the message queue.\n * @param buffer Pointer to ring buffer that holds queued messages.\n * @param msg_size Message size (in bytes).\n * @param max_msgs Maximum number of messages that can be queued.\n */\nvoid k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,\n\t\t uint32_t max_msgs);\n\n/**\n * @brief Initialize a message queue.\n *\n * This routine initializes a message queue object, prior to its first use,\n * allocating its internal ring buffer from the calling thread&#x27;s resource\n * pool.\n *\n * Memory allocated for the ring buffer can be released by calling\n * k_msgq_cleanup(), or if userspace is enabled and the msgq object loses\n * all of its references.\n *\n * @param msgq Address of the message queue.\n * @param msg_size Message size (in bytes).\n * @param max_msgs Maximum number of messages that can be queued.\n *\n * @return 0 on success, -ENOMEM if there was insufficient memory in the\n *\tthread&#x27;s resource pool, or -EINVAL if the size parameters cause\n *\tan integer overflow.\n */\n__syscall int k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,\n\t\t\t\tuint32_t max_msgs);\n\n/**\n * @brief Release allocated buffer for a queue\n *\n * Releases memory allocated for the ring buffer.\n *\n * @param msgq message queue to cleanup\n *\n * @retval 0 on success\n * @retval -EBUSY Queue not empty\n */\nint k_msgq_cleanup(struct k_msgq *msgq);\n\n/**\n * @brief Send a message to a message queue.\n *\n * This routine sends a message to message queue @a q.\n *\n * @note The message content is copied from @a data into @a msgq and the @a data\n * pointer is not retained, so the message content will not be modified\n * by this function.\n *\n * @funcprops \\isr_ok\n *\n * @param msgq Address of the message queue.\n * @param data Pointer to the message.\n * @param timeout Waiting period to add the message, or one of the special\n *                values K_NO_WAIT and K_FOREVER.\n *\n * @retval 0 Message sent.\n * @retval -ENOMSG Returned without waiting or queue purged.\n * @retval -EAGAIN Waiting period timed out.\n */\n__syscall int k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout);\n\n/**\n * @brief Receive a message from a message queue.\n *\n * This routine receives a message from message queue @a q in a &quot;first in,\n * first out&quot; manner.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n *\n * @funcprops \\isr_ok\n *\n * @param msgq Address of the message queue.\n * @param data Address of area to hold the received message.\n * @param timeout Waiting period to receive the message,\n *                or one of the special values K_NO_WAIT and\n *                K_FOREVER.\n *\n * @retval 0 Message received.\n * @retval -ENOMSG Returned without waiting or queue purged.\n * @retval -EAGAIN Waiting period timed out.\n */\n__syscall int k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout);\n\n/**\n * @brief Peek/read a message from a message queue.\n *\n * This routine reads a message from message queue @a q in a &quot;first in,\n * first out&quot; manner and leaves the message in the queue.\n *\n * @funcprops \\isr_ok\n *\n * @param msgq Address of the message queue.\n * @param data Address of area to hold the message read from the queue.\n *\n * @retval 0 Message read.\n * @retval -ENOMSG Returned when the queue has no message.\n */\n__syscall int k_msgq_peek(struct k_msgq *msgq, void *data);\n\n/**\n * @brief Peek/read a message from a message queue at the specified index\n *\n * This routine reads a message from message queue at the specified index\n * and leaves the message in the queue.\n * k_msgq_peek_at(msgq, data, 0) is equivalent to k_msgq_peek(msgq, data)\n *\n * @funcprops \\isr_ok\n *\n * @param msgq Address of the message queue.\n * @param data Address of area to hold the message read from the queue.\n * @param idx Message queue index at which to peek\n *\n * @retval 0 Message read.\n * @retval -ENOMSG Returned when the queue has no message at index.\n */\n__syscall int k_msgq_peek_at(struct k_msgq *msgq, void *data, uint32_t idx);\n\n/**\n * @brief Purge a message queue.\n *\n * This routine discards all unreceived messages in a message queue&#x27;s ring\n * buffer. Any threads that are blocked waiting to send a message to the\n * message queue are unblocked and see an -ENOMSG error code.\n *\n * @param msgq Address of the message queue.\n */\n__syscall void k_msgq_purge(struct k_msgq *msgq);\n\n/**\n * @brief Get the amount of free space in a message queue.\n *\n * This routine returns the number of unused entries in a message queue&#x27;s\n * ring buffer.\n *\n * @param msgq Address of the message queue.\n *\n * @return Number of unused ring buffer entries.\n */\n__syscall uint32_t k_msgq_num_free_get(struct k_msgq *msgq);\n\n/**\n * @brief Get basic attributes of a message queue.\n *\n * This routine fetches basic attributes of message queue into attr argument.\n *\n * @param msgq Address of the message queue.\n * @param attrs pointer to message queue attribute structure.\n */\n__syscall void  k_msgq_get_attrs(struct k_msgq *msgq,\n\t\t\t\t struct k_msgq_attrs *attrs);\n\n\nstatic inline uint32_t z_impl_k_msgq_num_free_get(struct k_msgq *msgq)\n{\n\treturn msgq-&gt;max_msgs - msgq-&gt;used_msgs;\n}\n\n/**\n * @brief Get the number of messages in a message queue.\n *\n * This routine returns the number of messages in a message queue&#x27;s ring buffer.\n *\n * @param msgq Address of the message queue.\n *\n * @return Number of messages.\n */\n__syscall uint32_t k_msgq_num_used_get(struct k_msgq *msgq);\n\nstatic inline uint32_t z_impl_k_msgq_num_used_get(struct k_msgq *msgq)\n{\n\treturn msgq-&gt;used_msgs;\n}\n\n/** @} */\n\n/**\n * @defgroup mailbox_apis Mailbox APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Mailbox Message Structure\n *\n */\nstruct k_mbox_msg {\n\t/** size of message (in bytes) */\n\tsize_t size;\n\t/** application-defined information value */\n\tuint32_t info;\n\t/** sender&#x27;s message data buffer */\n\tvoid *tx_data;\n\t/** source thread id */\n\tk_tid_t rx_source_thread;\n\t/** target thread id */\n\tk_tid_t tx_target_thread;\n\t/** internal use only - thread waiting on send (may be a dummy) */\n\tk_tid_t _syncing_thread;\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS &gt; 0)\n\t/** internal use only - semaphore used during asynchronous send */\n\tstruct k_sem *_async_sem;\n#endif\n};\n/**\n * @brief Mailbox Structure\n *\n */\nstruct k_mbox {\n\t/** Transmit messages queue */\n\t_wait_q_t tx_msg_queue;\n\t/** Receive message queue */\n\t_wait_q_t rx_msg_queue;\n\tstruct k_spinlock lock;\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_mbox)\n\n#ifdef CONFIG_OBJ_CORE_MAILBOX\n\tstruct k_obj_core  obj_core;\n#endif\n};\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n#define Z_MBOX_INITIALIZER(obj) \\\n\t{ \\\n\t.tx_msg_queue = Z_WAIT_Q_INIT(&amp;obj.tx_msg_queue), \\\n\t.rx_msg_queue = Z_WAIT_Q_INIT(&amp;obj.rx_msg_queue), \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @brief Statically define and initialize a mailbox.\n *\n * The mailbox is to be accessed outside the module where it is defined using:\n *\n * @code extern struct k_mbox &lt;name&gt;; @endcode\n *\n * @param name Name of the mailbox.\n */\n#define K_MBOX_DEFINE(name) \\\n\tSTRUCT_SECTION_ITERABLE(k_mbox, name) = \\\n\t\tZ_MBOX_INITIALIZER(name) \\\n\n/**\n * @brief Initialize a mailbox.\n *\n * This routine initializes a mailbox object, prior to its first use.\n *\n * @param mbox Address of the mailbox.\n */\nvoid k_mbox_init(struct k_mbox *mbox);\n\n/**\n * @brief Send a mailbox message in a synchronous manner.\n *\n * This routine sends a message to @a mbox and waits for a receiver to both\n * receive and process it. The message data may be in a buffer or non-existent\n * (i.e. an empty message).\n *\n * @param mbox Address of the mailbox.\n * @param tx_msg Address of the transmit message descriptor.\n * @param timeout Waiting period for the message to be received,\n *                or one of the special values K_NO_WAIT\n *                and K_FOREVER. Once the message has been received,\n *                this routine waits as long as necessary for the message\n *                to be completely processed.\n *\n * @retval 0 Message sent.\n * @retval -ENOMSG Returned without waiting.\n * @retval -EAGAIN Waiting period timed out.\n */\nint k_mbox_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,\n\t\t      k_timeout_t timeout);\n\n/**\n * @brief Send a mailbox message in an asynchronous manner.\n *\n * This routine sends a message to @a mbox without waiting for a receiver\n * to process it. The message data may be in a buffer or non-existent\n * (i.e. an empty message). Optionally, the semaphore @a sem will be given\n * when the message has been both received and completely processed by\n * the receiver.\n *\n * @param mbox Address of the mailbox.\n * @param tx_msg Address of the transmit message descriptor.\n * @param sem Address of a semaphore, or NULL if none is needed.\n */\nvoid k_mbox_async_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,\n\t\t\t     struct k_sem *sem);\n\n/**\n * @brief Receive a mailbox message.\n *\n * This routine receives a message from @a mbox, then optionally retrieves\n * its data and disposes of the message.\n *\n * @param mbox Address of the mailbox.\n * @param rx_msg Address of the receive message descriptor.\n * @param buffer Address of the buffer to receive data, or NULL to defer data\n *               retrieval and message disposal until later.\n * @param timeout Waiting period for a message to be received,\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n *\n * @retval 0 Message received.\n * @retval -ENOMSG Returned without waiting.\n * @retval -EAGAIN Waiting period timed out.\n */\nint k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg,\n\t\t      void *buffer, k_timeout_t timeout);\n\n/**\n * @brief Retrieve mailbox message data into a buffer.\n *\n * This routine completes the processing of a received message by retrieving\n * its data into a buffer, then disposing of the message.\n *\n * Alternatively, this routine can be used to dispose of a received message\n * without retrieving its data.\n *\n * @param rx_msg Address of the receive message descriptor.\n * @param buffer Address of the buffer to receive data, or NULL to discard\n *               the data.\n */\nvoid k_mbox_data_get(struct k_mbox_msg *rx_msg, void *buffer);\n\n/** @} */\n\n/**\n * @defgroup pipe_apis Pipe APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief initialize a pipe\n *\n * This routine initializes a pipe object, prior to its first use.\n *\n * @param pipe Address of the pipe.\n * @param buffer Address of the pipe&#x27;s buffer, or NULL if no ring buffer is used.\n * @param buffer_size Size of the pipe&#x27;s buffer, or zero if no ring buffer is used.\n */\n__syscall void k_pipe_init(struct k_pipe *pipe, uint8_t *buffer, size_t buffer_size);\n\n#ifdef CONFIG_PIPES\n/** Pipe Structure */\nstruct k_pipe {\n\tunsigned char *buffer;          /**&lt; Pipe buffer: may be NULL */\n\tsize_t         size;            /**&lt; Buffer size */\n\tsize_t         bytes_used;      /**&lt; Number of bytes used in buffer */\n\tsize_t         read_index;      /**&lt; Where in buffer to read from */\n\tsize_t         write_index;     /**&lt; Where in buffer to write */\n\tstruct k_spinlock lock;\t\t/**&lt; Synchronization lock */\n\n\tstruct {\n\t\t_wait_q_t      readers; /**&lt; Reader wait queue */\n\t\t_wait_q_t      writers; /**&lt; Writer wait queue */\n\t} wait_q;\t\t\t/** Wait queue */\n\n\tZ_DECL_POLL_EVENT\n\n\tuint8_t\t       flags;\t\t/**&lt; Flags */\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_pipe)\n\n#ifdef CONFIG_OBJ_CORE_PIPE\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n#define K_PIPE_FLAG_ALLOC\tBIT(0)\t/** Buffer was allocated */\n\n#define Z_PIPE_INITIALIZER(obj, pipe_buffer, pipe_buffer_size)     \\\n\t{                                                           \\\n\t.buffer = pipe_buffer,                                      \\\n\t.size = pipe_buffer_size,                                   \\\n\t.bytes_used = 0,                                            \\\n\t.read_index = 0,                                            \\\n\t.write_index = 0,                                           \\\n\t.lock = {},                                                 \\\n\t.wait_q = {                                                 \\\n\t\t.readers = Z_WAIT_Q_INIT(&amp;obj.wait_q.readers),       \\\n\t\t.writers = Z_WAIT_Q_INIT(&amp;obj.wait_q.writers)        \\\n\t},                                                          \\\n\tZ_POLL_EVENT_OBJ_INIT(obj)                                   \\\n\t.flags = 0,                                                 \\\n\t}\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @brief Statically define and initialize a pipe.\n *\n * The pipe can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_pipe &lt;name&gt;; @endcode\n *\n * @param name Name of the pipe.\n * @param pipe_buffer_size Size of the pipe&#x27;s ring buffer (in bytes),\n *                         or zero if no ring buffer is used.\n * @param pipe_align Alignment of the pipe&#x27;s ring buffer (power of 2).\n *\n */\n#define K_PIPE_DEFINE(name, pipe_buffer_size, pipe_align)\t\t\\\n\tstatic unsigned char __noinit __aligned(pipe_align)\t\t\\\n\t\t_k_pipe_buf_##name[pipe_buffer_size];\t\t\t\\\n\tSTRUCT_SECTION_ITERABLE(k_pipe, name) =\t\t\t\t\\\n\t\tZ_PIPE_INITIALIZER(name, _k_pipe_buf_##name, pipe_buffer_size)\n\n/**\n * @deprecated Dynamic allocation of pipe buffers will be removed in the new k_pipe API.\n * @brief Release a pipe&#x27;s allocated buffer\n *\n * If a pipe object was given a dynamically allocated buffer via\n * k_pipe_alloc_init(), this will free it. This function does nothing\n * if the buffer wasn&#x27;t dynamically allocated.\n *\n * @param pipe Address of the pipe.\n * @retval 0 on success\n * @retval -EAGAIN nothing to cleanup\n */\n__deprecated int k_pipe_cleanup(struct k_pipe *pipe);\n\n/**\n * @deprecated Dynamic allocation of pipe buffers will be removed in the new k_pipe API.\n * @brief Initialize a pipe and allocate a buffer for it\n *\n * Storage for the buffer region will be allocated from the calling thread&#x27;s\n * resource pool. This memory will be released if k_pipe_cleanup() is called,\n * or userspace is enabled and the pipe object loses all references to it.\n *\n * This function should only be called on uninitialized pipe objects.\n *\n * @param pipe Address of the pipe.\n * @param size Size of the pipe&#x27;s ring buffer (in bytes), or zero if no ring\n *             buffer is used.\n * @retval 0 on success\n * @retval -ENOMEM if memory couldn&#x27;t be allocated\n */\n__deprecated __syscall int k_pipe_alloc_init(struct k_pipe *pipe, size_t size);\n\n/**\n * @deprecated k_pipe_put() is replaced by k_pipe_write(...) in the new k_pipe API.\n * @brief Write data to a pipe.\n *\n * This routine writes up to @a bytes_to_write bytes of data to @a pipe.\n *\n * @param pipe Address of the pipe.\n * @param data Address of data to write.\n * @param bytes_to_write Size of data (in bytes).\n * @param bytes_written Address of area to hold the number of bytes written.\n * @param min_xfer Minimum number of bytes to write.\n * @param timeout Waiting period to wait for the data to be written,\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n *\n * @retval 0 At least @a min_xfer bytes of data were written.\n * @retval -EIO Returned without waiting; zero data bytes were written.\n * @retval -EAGAIN Waiting period timed out; between zero and @a min_xfer\n *                 minus one data bytes were written.\n */\n__deprecated __syscall int k_pipe_put(struct k_pipe *pipe, const void *data,\n\t\t\t size_t bytes_to_write, size_t *bytes_written,\n\t\t\t size_t min_xfer, k_timeout_t timeout);\n\n/**\n * @deprecated k_pipe_get() is replaced by k_pipe_read(...) in the new k_pipe API.\n * @brief Read data from a pipe.\n *\n * This routine reads up to @a bytes_to_read bytes of data from @a pipe.\n *\n * @param pipe Address of the pipe.\n * @param data Address to place the data read from pipe.\n * @param bytes_to_read Maximum number of data bytes to read.\n * @param bytes_read Address of area to hold the number of bytes read.\n * @param min_xfer Minimum number of data bytes to read.\n * @param timeout Waiting period to wait for the data to be read,\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n *\n * @retval 0 At least @a min_xfer bytes of data were read.\n * @retval -EINVAL invalid parameters supplied\n * @retval -EIO Returned without waiting; zero data bytes were read.\n * @retval -EAGAIN Waiting period timed out; between zero and @a min_xfer\n *                 minus one data bytes were read.\n */\n__deprecated  __syscall int k_pipe_get(struct k_pipe *pipe, void *data,\n\t\t\t size_t bytes_to_read, size_t *bytes_read,\n\t\t\t size_t min_xfer, k_timeout_t timeout);\n\n/**\n * @deprecated k_pipe_read_avail() will be removed in the new k_pipe API.\n * @brief Query the number of bytes that may be read from @a pipe.\n *\n * @param pipe Address of the pipe.\n *\n * @retval a number n such that 0 &lt;= n &lt;= @ref k_pipe.size; the\n *         result is zero for unbuffered pipes.\n */\n__deprecated  __syscall size_t k_pipe_read_avail(struct k_pipe *pipe);\n\n/**\n * @deprecated k_pipe_write_avail() will be removed in the new k_pipe API.\n * @brief Query the number of bytes that may be written to @a pipe\n *\n * @param pipe Address of the pipe.\n *\n * @retval a number n such that 0 &lt;= n &lt;= @ref k_pipe.size; the\n *         result is zero for unbuffered pipes.\n */\n__deprecated __syscall size_t k_pipe_write_avail(struct k_pipe *pipe);\n\n/**\n * @deprecated k_pipe_flush() will be removed in the new k_pipe API.\n * @brief Flush the pipe of write data\n *\n * This routine flushes the pipe. Flushing the pipe is equivalent to reading\n * both all the data in the pipe&#x27;s buffer and all the data waiting to go into\n * that pipe into a large temporary buffer and discarding the buffer. Any\n * writers that were previously pended become unpended.\n *\n * @param pipe Address of the pipe.\n */\n__deprecated __syscall void k_pipe_flush(struct k_pipe *pipe);\n\n/**\n * @deprecated k_pipe_buffer_flush will be removed in the new k_pipe API.\n * @brief Flush the pipe&#x27;s internal buffer\n *\n * This routine flushes the pipe&#x27;s internal buffer. This is equivalent to\n * reading up to N bytes from the pipe (where N is the size of the pipe&#x27;s\n * buffer) into a temporary buffer and then discarding that buffer. If there\n * were writers previously pending, then some may unpend as they try to fill\n * up the pipe&#x27;s emptied buffer.\n *\n * @param pipe Address of the pipe.\n */\n__deprecated __syscall void k_pipe_buffer_flush(struct k_pipe *pipe);\n\n#else /* CONFIG_PIPES */\n\nenum pipe_flags {\n\tPIPE_FLAG_OPEN = BIT(0),\n\tPIPE_FLAG_RESET = BIT(1),\n};\n\nstruct k_pipe {\n\tsize_t waiting;\n\tstruct ring_buf buf;\n\tstruct k_spinlock lock;\n\t_wait_q_t data;\n\t_wait_q_t space;\n\tuint8_t flags;\n\n\tZ_DECL_POLL_EVENT\n#ifdef CONFIG_OBJ_CORE_PIPE\n\tstruct k_obj_core  obj_core;\n#endif\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_pipe)\n};\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n#define Z_PIPE_INITIALIZER(obj, pipe_buffer, pipe_buffer_size)\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.buf = RING_BUF_INIT(pipe_buffer, pipe_buffer_size),\t\\\n\t.data = Z_WAIT_Q_INIT(&amp;obj.data),\t\t\t\\\n\t.space = Z_WAIT_Q_INIT(&amp;obj.space),\t\t\t\\\n\t.flags = PIPE_FLAG_OPEN,\t\t\t\t\\\n\t.waiting = 0,\t\t\t\t\t\t\\\n\tZ_POLL_EVENT_OBJ_INIT(obj)\t\t\t\t\\\n}\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @brief Statically define and initialize a pipe.\n *\n * The pipe can be accessed outside the module where it is defined using:\n *\n * @code extern struct k_pipe &lt;name&gt;; @endcode\n *\n * @param name Name of the pipe.\n * @param pipe_buffer_size Size of the pipe&#x27;s ring buffer (in bytes)\n *                         or zero if no ring buffer is used.\n * @param pipe_align Alignment of the pipe&#x27;s ring buffer (power of 2).\n *\n */\n#define K_PIPE_DEFINE(name, pipe_buffer_size, pipe_align)\t\t\\\n\tstatic unsigned char __noinit __aligned(pipe_align)\t\t\\\n\t\t_k_pipe_buf_##name[pipe_buffer_size];\t\t\t\\\n\tSTRUCT_SECTION_ITERABLE(k_pipe, name) =\t\t\t\t\\\n\t\tZ_PIPE_INITIALIZER(name, _k_pipe_buf_##name, pipe_buffer_size)\n\n\n/**\n * @brief Write data to a pipe\n *\n * This routine writes up to @a len bytes of data to @a pipe.\n * If the pipe is full, the routine will block until the data can be written or the timeout expires.\n *\n * @param pipe Address of the pipe.\n * @param data Address of data to write.\n * @param len Size of data (in bytes).\n * @param timeout Waiting period to wait for the data to be written.\n *\n * @retval number of bytes written on success\n * @retval -EAGAIN if no data could be written before the timeout expired\n * @retval -ECANCELED if the write was interrupted by k_pipe_reset(..)\n * @retval -EPIPE if the pipe was closed\n */\n__syscall int k_pipe_write(struct k_pipe *pipe, const uint8_t *data, size_t len,\n\t\t\t   k_timeout_t timeout);\n\n/**\n * @brief Read data from a pipe\n * This routine reads up to @a len bytes of data from @a pipe.\n * If the pipe is empty, the routine will block until the data can be read or the timeout expires.\n *\n * @param pipe Address of the pipe.\n * @param data Address to place the data read from pipe.\n * @param len Requested number of bytes to read.\n * @param timeout Waiting period to wait for the data to be read.\n *\n * @retval number of bytes read on success\n * @retval -EAGAIN if no data could be read before the timeout expired\n * @retval -ECANCELED if the read was interrupted by k_pipe_reset(..)\n * @retval -EPIPE if the pipe was closed\n */\n__syscall int k_pipe_read(struct k_pipe *pipe, uint8_t *data, size_t len,\n\t\t\t  k_timeout_t timeout);\n\n/**\n * @brief Reset a pipe\n * This routine resets the pipe, discarding any unread data and unblocking any threads waiting to\n * write or read, causing the waiting threads to return with -ECANCELED. Calling k_pipe_read(..) or\n * k_pipe_write(..) when the pipe is resetting but not yet reset will return -ECANCELED.\n * The pipe is left open after a reset and can be used as normal.\n *\n * @param pipe Address of the pipe.\n */\n__syscall void k_pipe_reset(struct k_pipe *pipe);\n\n/**\n * @brief Close a pipe\n *\n * This routine closes a pipe. Any threads that were blocked on the pipe\n * will be unblocked and receive an error code.\n *\n * @param pipe Address of the pipe.\n */\n__syscall void k_pipe_close(struct k_pipe *pipe);\n#endif /* CONFIG_PIPES */\n/** @} */\n\n/**\n * @cond INTERNAL_HIDDEN\n */\nstruct k_mem_slab_info {\n\tuint32_t num_blocks;\n\tsize_t   block_size;\n\tuint32_t num_used;\n#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION\n\tuint32_t max_used;\n#endif\n};\n\nstruct k_mem_slab {\n\t_wait_q_t wait_q;\n\tstruct k_spinlock lock;\n\tchar *buffer;\n\tchar *free_list;\n\tstruct k_mem_slab_info info;\n\n\tSYS_PORT_TRACING_TRACKING_FIELD(k_mem_slab)\n\n#ifdef CONFIG_OBJ_CORE_MEM_SLAB\n\tstruct k_obj_core  obj_core;\n#endif\n};\n\n#define Z_MEM_SLAB_INITIALIZER(_slab, _slab_buffer, _slab_block_size, \\\n\t\t\t       _slab_num_blocks)                      \\\n\t{                                                             \\\n\t.wait_q = Z_WAIT_Q_INIT(&amp;(_slab).wait_q),                     \\\n\t.lock = {},                                                   \\\n\t.buffer = _slab_buffer,                                       \\\n\t.free_list = NULL,                                            \\\n\t.info = {_slab_num_blocks, _slab_block_size, 0}               \\\n\t}\n\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @defgroup mem_slab_apis Memory Slab APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Statically define and initialize a memory slab in a public (non-static) scope.\n *\n * The memory slab&#x27;s buffer contains @a slab_num_blocks memory blocks\n * that are @a slab_block_size bytes long. The buffer is aligned to a\n * @a slab_align -byte boundary. To ensure that each memory block is similarly\n * aligned to this boundary, @a slab_block_size must also be a multiple of\n * @a slab_align.\n *\n * The memory slab can be accessed outside the module where it is defined\n * using:\n *\n * @code extern struct k_mem_slab &lt;name&gt;; @endcode\n *\n * @note This macro cannot be used together with a static keyword.\n *       If such a use-case is desired, use @ref K_MEM_SLAB_DEFINE_STATIC\n *       instead.\n *\n * @param name Name of the memory slab.\n * @param slab_block_size Size of each memory block (in bytes).\n * @param slab_num_blocks Number memory blocks.\n * @param slab_align Alignment of the memory slab&#x27;s buffer (power of 2).\n */\n#define K_MEM_SLAB_DEFINE(name, slab_block_size, slab_num_blocks, slab_align) \\\n\tchar __noinit_named(k_mem_slab_buf_##name) \\\n\t   __aligned(WB_UP(slab_align)) \\\n\t   _k_mem_slab_buf_##name[(slab_num_blocks) * WB_UP(slab_block_size)]; \\\n\tSTRUCT_SECTION_ITERABLE(k_mem_slab, name) = \\\n\t\tZ_MEM_SLAB_INITIALIZER(name, _k_mem_slab_buf_##name, \\\n\t\t\t\t\tWB_UP(slab_block_size), slab_num_blocks)\n\n/**\n * @brief Statically define and initialize a memory slab in a private (static) scope.\n *\n * The memory slab&#x27;s buffer contains @a slab_num_blocks memory blocks\n * that are @a slab_block_size bytes long. The buffer is aligned to a\n * @a slab_align -byte boundary. To ensure that each memory block is similarly\n * aligned to this boundary, @a slab_block_size must also be a multiple of\n * @a slab_align.\n *\n * @param name Name of the memory slab.\n * @param slab_block_size Size of each memory block (in bytes).\n * @param slab_num_blocks Number memory blocks.\n * @param slab_align Alignment of the memory slab&#x27;s buffer (power of 2).\n */\n#define K_MEM_SLAB_DEFINE_STATIC(name, slab_block_size, slab_num_blocks, slab_align) \\\n\tstatic char __noinit_named(k_mem_slab_buf_##name) \\\n\t   __aligned(WB_UP(slab_align)) \\\n\t   _k_mem_slab_buf_##name[(slab_num_blocks) * WB_UP(slab_block_size)]; \\\n\tstatic STRUCT_SECTION_ITERABLE(k_mem_slab, name) = \\\n\t\tZ_MEM_SLAB_INITIALIZER(name, _k_mem_slab_buf_##name, \\\n\t\t\t\t\tWB_UP(slab_block_size), slab_num_blocks)\n\n/**\n * @brief Initialize a memory slab.\n *\n * Initializes a memory slab, prior to its first use.\n *\n * The memory slab&#x27;s buffer contains @a slab_num_blocks memory blocks\n * that are @a slab_block_size bytes long. The buffer must be aligned to an\n * N-byte boundary matching a word boundary, where N is a power of 2\n * (i.e. 4 on 32-bit systems, 8, 16, ...).\n * To ensure that each memory block is similarly aligned to this boundary,\n * @a slab_block_size must also be a multiple of N.\n *\n * @param slab Address of the memory slab.\n * @param buffer Pointer to buffer used for the memory blocks.\n * @param block_size Size of each memory block (in bytes).\n * @param num_blocks Number of memory blocks.\n *\n * @retval 0 on success\n * @retval -EINVAL invalid data supplied\n *\n */\nint k_mem_slab_init(struct k_mem_slab *slab, void *buffer,\n\t\t\t   size_t block_size, uint32_t num_blocks);\n\n/**\n * @brief Allocate memory from a memory slab.\n *\n * This routine allocates a memory block from a memory slab.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n *\n * @funcprops \\isr_ok\n *\n * @param slab Address of the memory slab.\n * @param mem Pointer to block address area.\n * @param timeout Waiting period to wait for operation to complete.\n *        Use K_NO_WAIT to return without waiting,\n *        or K_FOREVER to wait as long as necessary.\n *\n * @retval 0 Memory allocated. The block address area pointed at by @a mem\n *         is set to the starting address of the memory block.\n * @retval -ENOMEM Returned without waiting.\n * @retval -EAGAIN Waiting period timed out.\n * @retval -EINVAL Invalid data supplied\n */\nint k_mem_slab_alloc(struct k_mem_slab *slab, void **mem,\n\t\t\t    k_timeout_t timeout);\n\n/**\n * @brief Free memory allocated from a memory slab.\n *\n * This routine releases a previously allocated memory block back to its\n * associated memory slab.\n *\n * @param slab Address of the memory slab.\n * @param mem Pointer to the memory block (as returned by k_mem_slab_alloc()).\n */\nvoid k_mem_slab_free(struct k_mem_slab *slab, void *mem);\n\n/**\n * @brief Get the number of used blocks in a memory slab.\n *\n * This routine gets the number of memory blocks that are currently\n * allocated in @a slab.\n *\n * @param slab Address of the memory slab.\n *\n * @return Number of allocated memory blocks.\n */\nstatic inline uint32_t k_mem_slab_num_used_get(struct k_mem_slab *slab)\n{\n\treturn slab-&gt;info.num_used;\n}\n\n/**\n * @brief Get the number of maximum used blocks so far in a memory slab.\n *\n * This routine gets the maximum number of memory blocks that were\n * allocated in @a slab.\n *\n * @param slab Address of the memory slab.\n *\n * @return Maximum number of allocated memory blocks.\n */\nstatic inline uint32_t k_mem_slab_max_used_get(struct k_mem_slab *slab)\n{\n#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION\n\treturn slab-&gt;info.max_used;\n#else\n\tARG_UNUSED(slab);\n\treturn 0;\n#endif\n}\n\n/**\n * @brief Get the number of unused blocks in a memory slab.\n *\n * This routine gets the number of memory blocks that are currently\n * unallocated in @a slab.\n *\n * @param slab Address of the memory slab.\n *\n * @return Number of unallocated memory blocks.\n */\nstatic inline uint32_t k_mem_slab_num_free_get(struct k_mem_slab *slab)\n{\n\treturn slab-&gt;info.num_blocks - slab-&gt;info.num_used;\n}\n\n/**\n * @brief Get the memory stats for a memory slab\n *\n * This routine gets the runtime memory usage stats for the slab @a slab.\n *\n * @param slab Address of the memory slab\n * @param stats Pointer to memory into which to copy memory usage statistics\n *\n * @retval 0 Success\n * @retval -EINVAL Any parameter points to NULL\n */\n\nint k_mem_slab_runtime_stats_get(struct k_mem_slab *slab, struct sys_memory_stats *stats);\n\n/**\n * @brief Reset the maximum memory usage for a slab\n *\n * This routine resets the maximum memory usage for the slab @a slab to its\n * current usage.\n *\n * @param slab Address of the memory slab\n *\n * @retval 0 Success\n * @retval -EINVAL Memory slab is NULL\n */\nint k_mem_slab_runtime_stats_reset_max(struct k_mem_slab *slab);\n\n/** @} */\n\n/**\n * @addtogroup heap_apis\n * @{\n */\n\n/* kernel synchronized heap struct */\n\nstruct k_heap {\n\tstruct sys_heap heap;\n\t_wait_q_t wait_q;\n\tstruct k_spinlock lock;\n};\n\n/**\n * @brief Initialize a k_heap\n *\n * This constructs a synchronized k_heap object over a memory region\n * specified by the user.  Note that while any alignment and size can\n * be passed as valid parameters, internal alignment restrictions\n * inside the inner sys_heap mean that not all bytes may be usable as\n * allocated memory.\n *\n * @param h Heap struct to initialize\n * @param mem Pointer to memory.\n * @param bytes Size of memory region, in bytes\n */\nvoid k_heap_init(struct k_heap *h, void *mem,\n\t\tsize_t bytes) __attribute_nonnull(1);\n\n/**\n * @brief Allocate aligned memory from a k_heap\n *\n * Behaves in all ways like k_heap_alloc(), except that the returned\n * memory (if available) will have a starting address in memory which\n * is a multiple of the specified power-of-two alignment value in\n * bytes.  The resulting memory can be returned to the heap using\n * k_heap_free().\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n *\n * @funcprops \\isr_ok\n *\n * @param h Heap from which to allocate\n * @param align Alignment in bytes, must be a power of two\n * @param bytes Number of bytes requested\n * @param timeout How long to wait, or K_NO_WAIT\n * @return Pointer to memory the caller can now use\n */\nvoid *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,\n\t\t\tk_timeout_t timeout) __attribute_nonnull(1);\n\n/**\n * @brief Allocate memory from a k_heap\n *\n * Allocates and returns a memory buffer from the memory region owned\n * by the heap.  If no memory is available immediately, the call will\n * block for the specified timeout (constructed via the standard\n * timeout API, or K_NO_WAIT or K_FOREVER) waiting for memory to be\n * freed.  If the allocation cannot be performed by the expiration of\n * the timeout, NULL will be returned.\n * Allocated memory is aligned on a multiple of pointer sizes.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n *\n * @funcprops \\isr_ok\n *\n * @param h Heap from which to allocate\n * @param bytes Desired size of block to allocate\n * @param timeout How long to wait, or K_NO_WAIT\n * @return A pointer to valid heap memory, or NULL\n */\nvoid *k_heap_alloc(struct k_heap *h, size_t bytes,\n\t\tk_timeout_t timeout) __attribute_nonnull(1);\n\n/**\n * @brief Allocate and initialize memory for an array of objects from a k_heap\n *\n * Allocates memory for an array of num objects of size and initializes all\n * bytes in the allocated storage to zero.  If no memory is available\n * immediately, the call will block for the specified timeout (constructed\n * via the standard timeout API, or K_NO_WAIT or K_FOREVER) waiting for memory\n * to be freed.  If the allocation cannot be performed by the expiration of\n * the timeout, NULL will be returned.\n * Allocated memory is aligned on a multiple of pointer sizes.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n *\n * @funcprops \\isr_ok\n *\n * @param h Heap from which to allocate\n * @param num Number of objects to allocate\n * @param size Desired size of each object to allocate\n * @param timeout How long to wait, or K_NO_WAIT\n * @return A pointer to valid heap memory, or NULL\n */\nvoid *k_heap_calloc(struct k_heap *h, size_t num, size_t size, k_timeout_t timeout)\n\t__attribute_nonnull(1);\n\n/**\n * @brief Reallocate memory from a k_heap\n *\n * Reallocates and returns a memory buffer from the memory region owned\n * by the heap.  If no memory is available immediately, the call will\n * block for the specified timeout (constructed via the standard\n * timeout API, or K_NO_WAIT or K_FOREVER) waiting for memory to be\n * freed.  If the allocation cannot be performed by the expiration of\n * the timeout, NULL will be returned.\n * Reallocated memory is aligned on a multiple of pointer sizes.\n *\n * @note @a timeout must be set to K_NO_WAIT if called from ISR.\n * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n *\n * @funcprops \\isr_ok\n *\n * @param h Heap from which to allocate\n * @param ptr Original pointer returned from a previous allocation\n * @param bytes Desired size of block to allocate\n * @param timeout How long to wait, or K_NO_WAIT\n *\n * @return Pointer to memory the caller can now use, or NULL\n */\nvoid *k_heap_realloc(struct k_heap *h, void *ptr, size_t bytes, k_timeout_t timeout)\n\t__attribute_nonnull(1);\n\n/**\n * @brief Free memory allocated by k_heap_alloc()\n *\n * Returns the specified memory block, which must have been returned\n * from k_heap_alloc(), to the heap for use by other callers.  Passing\n * a NULL block is legal, and has no effect.\n *\n * @param h Heap to which to return the memory\n * @param mem A valid memory block, or NULL\n */\nvoid k_heap_free(struct k_heap *h, void *mem) __attribute_nonnull(1);\n\n/* Hand-calculated minimum heap sizes needed to return a successful\n * 1-byte allocation.  See details in lib/os/heap.[ch]\n */\n#define Z_HEAP_MIN_SIZE ((sizeof(void *) &gt; 4) ? 56 : 44)\n\n/**\n * @brief Define a static k_heap in the specified linker section\n *\n * This macro defines and initializes a static memory region and\n * k_heap of the requested size in the specified linker section.\n * After kernel start, &amp;name can be used as if k_heap_init() had\n * been called.\n *\n * Note that this macro enforces a minimum size on the memory region\n * to accommodate metadata requirements.  Very small heaps will be\n * padded to fit.\n *\n * @param name Symbol name for the struct k_heap object\n * @param bytes Size of memory region, in bytes\n * @param in_section __attribute__((section(name))\n */\n#define Z_HEAP_DEFINE_IN_SECT(name, bytes, in_section)\t\t\\\n\tchar in_section\t\t\t\t\t\t\\\n\t     __aligned(8) /* CHUNK_UNIT */\t\t\t\\\n\t     kheap_##name[MAX(bytes, Z_HEAP_MIN_SIZE)];\t\t\\\n\tSTRUCT_SECTION_ITERABLE(k_heap, name) = {\t\t\\\n\t\t.heap = {\t\t\t\t\t\\\n\t\t\t.init_mem = kheap_##name,\t\t\\\n\t\t\t.init_bytes = MAX(bytes, Z_HEAP_MIN_SIZE), \\\n\t\t },\t\t\t\t\t\t\\\n\t}\n\n/**\n * @brief Define a static k_heap\n *\n * This macro defines and initializes a static memory region and\n * k_heap of the requested size.  After kernel start, &amp;name can be\n * used as if k_heap_init() had been called.\n *\n * Note that this macro enforces a minimum size on the memory region\n * to accommodate metadata requirements.  Very small heaps will be\n * padded to fit.\n *\n * @param name Symbol name for the struct k_heap object\n * @param bytes Size of memory region, in bytes\n */\n#define K_HEAP_DEFINE(name, bytes)\t\t\t\t\\\n\tZ_HEAP_DEFINE_IN_SECT(name, bytes,\t\t\t\\\n\t\t\t      __noinit_named(kheap_buf_##name))\n\n/**\n * @brief Define a static k_heap in uncached memory\n *\n * This macro defines and initializes a static memory region and\n * k_heap of the requested size in uncached memory.  After kernel\n * start, &amp;name can be used as if k_heap_init() had been called.\n *\n * Note that this macro enforces a minimum size on the memory region\n * to accommodate metadata requirements.  Very small heaps will be\n * padded to fit.\n *\n * @param name Symbol name for the struct k_heap object\n * @param bytes Size of memory region, in bytes\n */\n#define K_HEAP_DEFINE_NOCACHE(name, bytes)\t\t\t\\\n\tZ_HEAP_DEFINE_IN_SECT(name, bytes, __nocache)\n\n/**\n * @}\n */\n\n/**\n * @defgroup heap_apis Heap APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Allocate memory from the heap with a specified alignment.\n *\n * This routine provides semantics similar to aligned_alloc(); memory is\n * allocated from the heap with a specified alignment. However, one minor\n * difference is that k_aligned_alloc() accepts any non-zero @p size,\n * whereas aligned_alloc() only accepts a @p size that is an integral\n * multiple of @p align.\n *\n * Above, aligned_alloc() refers to:\n * C11 standard (ISO/IEC 9899:2011): 7.22.3.1\n * The aligned_alloc function (p: 347-348)\n *\n * @param align Alignment of memory requested (in bytes).\n * @param size Amount of memory requested (in bytes).\n *\n * @return Address of the allocated memory if successful; otherwise NULL.\n */\nvoid *k_aligned_alloc(size_t align, size_t size);\n\n/**\n * @brief Allocate memory from the heap.\n *\n * This routine provides traditional malloc() semantics. Memory is\n * allocated from the heap memory pool.\n * Allocated memory is aligned on a multiple of pointer sizes.\n *\n * @param size Amount of memory requested (in bytes).\n *\n * @return Address of the allocated memory if successful; otherwise NULL.\n */\nvoid *k_malloc(size_t size);\n\n/**\n * @brief Free memory allocated from heap.\n *\n * This routine provides traditional free() semantics. The memory being\n * returned must have been allocated from the heap memory pool.\n *\n * If @a ptr is NULL, no operation is performed.\n *\n * @param ptr Pointer to previously allocated memory.\n */\nvoid k_free(void *ptr);\n\n/**\n * @brief Allocate memory from heap, array style\n *\n * This routine provides traditional calloc() semantics. Memory is\n * allocated from the heap memory pool and zeroed.\n *\n * @param nmemb Number of elements in the requested array\n * @param size Size of each array element (in bytes).\n *\n * @return Address of the allocated memory if successful; otherwise NULL.\n */\nvoid *k_calloc(size_t nmemb, size_t size);\n\n/** @brief Expand the size of an existing allocation\n *\n * Returns a pointer to a new memory region with the same contents,\n * but a different allocated size.  If the new allocation can be\n * expanded in place, the pointer returned will be identical.\n * Otherwise the data will be copies to a new block and the old one\n * will be freed as per sys_heap_free().  If the specified size is\n * smaller than the original, the block will be truncated in place and\n * the remaining memory returned to the heap.  If the allocation of a\n * new block fails, then NULL will be returned and the old block will\n * not be freed or modified.\n *\n * @param ptr Original pointer returned from a previous allocation\n * @param size Amount of memory requested (in bytes).\n *\n * @return Pointer to memory the caller can now use, or NULL.\n */\nvoid *k_realloc(void *ptr, size_t size);\n\n/** @} */\n\n/* polling API - PRIVATE */\n\n#ifdef CONFIG_POLL\n#define _INIT_OBJ_POLL_EVENT(obj) do { (obj)-&gt;poll_event = NULL; } while (false)\n#else\n#define _INIT_OBJ_POLL_EVENT(obj) do { } while (false)\n#endif\n\n/* private - types bit positions */\nenum _poll_types_bits {\n\t/* can be used to ignore an event */\n\t_POLL_TYPE_IGNORE,\n\n\t/* to be signaled by k_poll_signal_raise() */\n\t_POLL_TYPE_SIGNAL,\n\n\t/* semaphore availability */\n\t_POLL_TYPE_SEM_AVAILABLE,\n\n\t/* queue/FIFO/LIFO data availability */\n\t_POLL_TYPE_DATA_AVAILABLE,\n\n\t/* msgq data availability */\n\t_POLL_TYPE_MSGQ_DATA_AVAILABLE,\n\n\t/* pipe data availability */\n\t_POLL_TYPE_PIPE_DATA_AVAILABLE,\n\n\t_POLL_NUM_TYPES\n};\n\n#define Z_POLL_TYPE_BIT(type) (1U &lt;&lt; ((type) - 1U))\n\n/* private - states bit positions */\nenum _poll_states_bits {\n\t/* default state when creating event */\n\t_POLL_STATE_NOT_READY,\n\n\t/* signaled by k_poll_signal_raise() */\n\t_POLL_STATE_SIGNALED,\n\n\t/* semaphore is available */\n\t_POLL_STATE_SEM_AVAILABLE,\n\n\t/* data is available to read on queue/FIFO/LIFO */\n\t_POLL_STATE_DATA_AVAILABLE,\n\n\t/* queue/FIFO/LIFO wait was cancelled */\n\t_POLL_STATE_CANCELLED,\n\n\t/* data is available to read on a message queue */\n\t_POLL_STATE_MSGQ_DATA_AVAILABLE,\n\n\t/* data is available to read from a pipe */\n\t_POLL_STATE_PIPE_DATA_AVAILABLE,\n\n\t_POLL_NUM_STATES\n};\n\n#define Z_POLL_STATE_BIT(state) (1U &lt;&lt; ((state) - 1U))\n\n#define _POLL_EVENT_NUM_UNUSED_BITS \\\n\t(32 - (0 \\\n\t       + 8 /* tag */ \\\n\t       + _POLL_NUM_TYPES \\\n\t       + _POLL_NUM_STATES \\\n\t       + 1 /* modes */ \\\n\t      ))\n\n/* end of polling API - PRIVATE */\n\n\n/**\n * @defgroup poll_apis Async polling APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/* Public polling API */\n\n/* public - values for k_poll_event.type bitfield */\n#define K_POLL_TYPE_IGNORE 0\n#define K_POLL_TYPE_SIGNAL Z_POLL_TYPE_BIT(_POLL_TYPE_SIGNAL)\n#define K_POLL_TYPE_SEM_AVAILABLE Z_POLL_TYPE_BIT(_POLL_TYPE_SEM_AVAILABLE)\n#define K_POLL_TYPE_DATA_AVAILABLE Z_POLL_TYPE_BIT(_POLL_TYPE_DATA_AVAILABLE)\n#define K_POLL_TYPE_FIFO_DATA_AVAILABLE K_POLL_TYPE_DATA_AVAILABLE\n#define K_POLL_TYPE_MSGQ_DATA_AVAILABLE Z_POLL_TYPE_BIT(_POLL_TYPE_MSGQ_DATA_AVAILABLE)\n#define K_POLL_TYPE_PIPE_DATA_AVAILABLE Z_POLL_TYPE_BIT(_POLL_TYPE_PIPE_DATA_AVAILABLE)\n\n/* public - polling modes */\nenum k_poll_modes {\n\t/* polling thread does not take ownership of objects when available */\n\tK_POLL_MODE_NOTIFY_ONLY = 0,\n\n\tK_POLL_NUM_MODES\n};\n\n/* public - values for k_poll_event.state bitfield */\n#define K_POLL_STATE_NOT_READY 0\n#define K_POLL_STATE_SIGNALED Z_POLL_STATE_BIT(_POLL_STATE_SIGNALED)\n#define K_POLL_STATE_SEM_AVAILABLE Z_POLL_STATE_BIT(_POLL_STATE_SEM_AVAILABLE)\n#define K_POLL_STATE_DATA_AVAILABLE Z_POLL_STATE_BIT(_POLL_STATE_DATA_AVAILABLE)\n#define K_POLL_STATE_FIFO_DATA_AVAILABLE K_POLL_STATE_DATA_AVAILABLE\n#define K_POLL_STATE_MSGQ_DATA_AVAILABLE Z_POLL_STATE_BIT(_POLL_STATE_MSGQ_DATA_AVAILABLE)\n#define K_POLL_STATE_PIPE_DATA_AVAILABLE Z_POLL_STATE_BIT(_POLL_STATE_PIPE_DATA_AVAILABLE)\n#define K_POLL_STATE_CANCELLED Z_POLL_STATE_BIT(_POLL_STATE_CANCELLED)\n\n/* public - poll signal object */\nstruct k_poll_signal {\n\t/** PRIVATE - DO NOT TOUCH */\n\tsys_dlist_t poll_events;\n\n\t/**\n\t * 1 if the event has been signaled, 0 otherwise. Stays set to 1 until\n\t * user resets it to 0.\n\t */\n\tunsigned int signaled;\n\n\t/** custom result value passed to k_poll_signal_raise() if needed */\n\tint result;\n};\n\n#define K_POLL_SIGNAL_INITIALIZER(obj) \\\n\t{ \\\n\t.poll_events = SYS_DLIST_STATIC_INIT(&amp;obj.poll_events), \\\n\t.signaled = 0, \\\n\t.result = 0, \\\n\t}\n/**\n * @brief Poll Event\n *\n */\nstruct k_poll_event {\n\t/** PRIVATE - DO NOT TOUCH */\n\tsys_dnode_t _node;\n\n\t/** PRIVATE - DO NOT TOUCH */\n\tstruct z_poller *poller;\n\n\t/** optional user-specified tag, opaque, untouched by the API */\n\tuint32_t tag:8;\n\n\t/** bitfield of event types (bitwise-ORed K_POLL_TYPE_xxx values) */\n\tuint32_t type:_POLL_NUM_TYPES;\n\n\t/** bitfield of event states (bitwise-ORed K_POLL_STATE_xxx values) */\n\tuint32_t state:_POLL_NUM_STATES;\n\n\t/** mode of operation, from enum k_poll_modes */\n\tuint32_t mode:1;\n\n\t/** unused bits in 32-bit word */\n\tuint32_t unused:_POLL_EVENT_NUM_UNUSED_BITS;\n\n\t/** per-type data */\n\tunion {\n\t\t/* The typed_* fields below are used by K_POLL_EVENT_*INITIALIZER() macros to ensure\n\t\t * type safety of polled objects.\n\t\t */\n\t\tvoid *obj, *typed_K_POLL_TYPE_IGNORE;\n\t\tstruct k_poll_signal *signal, *typed_K_POLL_TYPE_SIGNAL;\n\t\tstruct k_sem *sem, *typed_K_POLL_TYPE_SEM_AVAILABLE;\n\t\tstruct k_fifo *fifo, *typed_K_POLL_TYPE_FIFO_DATA_AVAILABLE;\n\t\tstruct k_queue *queue, *typed_K_POLL_TYPE_DATA_AVAILABLE;\n\t\tstruct k_msgq *msgq, *typed_K_POLL_TYPE_MSGQ_DATA_AVAILABLE;\n\t\tstruct k_pipe *pipe, *typed_K_POLL_TYPE_PIPE_DATA_AVAILABLE;\n\t};\n};\n\n#define K_POLL_EVENT_INITIALIZER(_event_type, _event_mode, _event_obj) \\\n\t{ \\\n\t.poller = NULL, \\\n\t.type = _event_type, \\\n\t.state = K_POLL_STATE_NOT_READY, \\\n\t.mode = _event_mode, \\\n\t.unused = 0, \\\n\t{ \\\n\t\t.typed_##_event_type = _event_obj, \\\n\t}, \\\n\t}\n\n#define K_POLL_EVENT_STATIC_INITIALIZER(_event_type, _event_mode, _event_obj, \\\n\t\t\t\t\tevent_tag) \\\n\t{ \\\n\t.tag = event_tag, \\\n\t.type = _event_type, \\\n\t.state = K_POLL_STATE_NOT_READY, \\\n\t.mode = _event_mode, \\\n\t.unused = 0, \\\n\t{ \\\n\t\t.typed_##_event_type = _event_obj, \\\n\t}, \\\n\t}\n\n/**\n * @brief Initialize one struct k_poll_event instance\n *\n * After this routine is called on a poll event, the event it ready to be\n * placed in an event array to be passed to k_poll().\n *\n * @param event The event to initialize.\n * @param type A bitfield of the types of event, from the K_POLL_TYPE_xxx\n *             values. Only values that apply to the same object being polled\n *             can be used together. Choosing K_POLL_TYPE_IGNORE disables the\n *             event.\n * @param mode Future. Use K_POLL_MODE_NOTIFY_ONLY.\n * @param obj Kernel object or poll signal.\n */\n\nvoid k_poll_event_init(struct k_poll_event *event, uint32_t type,\n\t\t\t      int mode, void *obj);\n\n/**\n * @brief Wait for one or many of multiple poll events to occur\n *\n * This routine allows a thread to wait concurrently for one or many of\n * multiple poll events to have occurred. Such events can be a kernel object\n * being available, like a semaphore, or a poll signal event.\n *\n * When an event notifies that a kernel object is available, the kernel object\n * is not &quot;given&quot; to the thread calling k_poll(): it merely signals the fact\n * that the object was available when the k_poll() call was in effect. Also,\n * all threads trying to acquire an object the regular way, i.e. by pending on\n * the object, have precedence over the thread polling on the object. This\n * means that the polling thread will never get the poll event on an object\n * until the object becomes available and its pend queue is empty. For this\n * reason, the k_poll() call is more effective when the objects being polled\n * only have one thread, the polling thread, trying to acquire them.\n *\n * When k_poll() returns 0, the caller should loop on all the events that were\n * passed to k_poll() and check the state field for the values that were\n * expected and take the associated actions.\n *\n * Before being reused for another call to k_poll(), the user has to reset the\n * state field to K_POLL_STATE_NOT_READY.\n *\n * When called from user mode, a temporary memory allocation is required from\n * the caller&#x27;s resource pool.\n *\n * @param events An array of events to be polled for.\n * @param num_events The number of events in the array.\n * @param timeout Waiting period for an event to be ready,\n *                or one of the special values K_NO_WAIT and K_FOREVER.\n *\n * @retval 0 One or more events are ready.\n * @retval -EAGAIN Waiting period timed out.\n * @retval -EINTR Polling has been interrupted, e.g. with\n *         k_queue_cancel_wait(). All output events are still set and valid,\n *         cancelled event(s) will be set to K_POLL_STATE_CANCELLED. In other\n *         words, -EINTR status means that at least one of output events is\n *         K_POLL_STATE_CANCELLED.\n * @retval -ENOMEM Thread resource pool insufficient memory (user mode only)\n * @retval -EINVAL Bad parameters (user mode only)\n */\n\n__syscall int k_poll(struct k_poll_event *events, int num_events,\n\t\t     k_timeout_t timeout);\n\n/**\n * @brief Initialize a poll signal object.\n *\n * Ready a poll signal object to be signaled via k_poll_signal_raise().\n *\n * @param sig A poll signal.\n */\n\n__syscall void k_poll_signal_init(struct k_poll_signal *sig);\n\n/**\n * @brief Reset a poll signal object&#x27;s state to unsignaled.\n *\n * @param sig A poll signal object\n */\n__syscall void k_poll_signal_reset(struct k_poll_signal *sig);\n\n/**\n * @brief Fetch the signaled state and result value of a poll signal\n *\n * @param sig A poll signal object\n * @param signaled An integer buffer which will be written nonzero if the\n *\t\t   object was signaled\n * @param result An integer destination buffer which will be written with the\n *\t\t   result value if the object was signaled, or an undefined\n *\t\t   value if it was not.\n */\n__syscall void k_poll_signal_check(struct k_poll_signal *sig,\n\t\t\t\t   unsigned int *signaled, int *result);\n\n/**\n * @brief Signal a poll signal object.\n *\n * This routine makes ready a poll signal, which is basically a poll event of\n * type K_POLL_TYPE_SIGNAL. If a thread was polling on that event, it will be\n * made ready to run. A @a result value can be specified.\n *\n * The poll signal contains a &#x27;signaled&#x27; field that, when set by\n * k_poll_signal_raise(), stays set until the user sets it back to 0 with\n * k_poll_signal_reset(). It thus has to be reset by the user before being\n * passed again to k_poll() or k_poll() will consider it being signaled, and\n * will return immediately.\n *\n * @note The result is stored and the &#x27;signaled&#x27; field is set even if\n * this function returns an error indicating that an expiring poll was\n * not notified.  The next k_poll() will detect the missed raise.\n *\n * @param sig A poll signal.\n * @param result The value to store in the result field of the signal.\n *\n * @retval 0 The signal was delivered successfully.\n * @retval -EAGAIN The polling thread&#x27;s timeout is in the process of expiring.\n */\n\n__syscall int k_poll_signal_raise(struct k_poll_signal *sig, int result);\n\n/** @} */\n\n/**\n * @defgroup cpu_idle_apis CPU Idling APIs\n * @ingroup kernel_apis\n * @{\n */\n/**\n * @brief Make the CPU idle.\n *\n * This function makes the CPU idle until an event wakes it up.\n *\n * In a regular system, the idle thread should be the only thread responsible\n * for making the CPU idle and triggering any type of power management.\n * However, in some more constrained systems, such as a single-threaded system,\n * the only thread would be responsible for this if needed.\n *\n * @note In some architectures, before returning, the function unmasks interrupts\n * unconditionally.\n */\nstatic inline void k_cpu_idle(void)\n{\n\tarch_cpu_idle();\n}\n\n/**\n * @brief Make the CPU idle in an atomic fashion.\n *\n * Similar to k_cpu_idle(), but must be called with interrupts locked.\n *\n * Enabling interrupts and entering a low-power mode will be atomic,\n * i.e. there will be no period of time where interrupts are enabled before\n * the processor enters a low-power mode.\n *\n * After waking up from the low-power mode, the interrupt lockout state will\n * be restored as if by irq_unlock(key).\n *\n * @param key Interrupt locking key obtained from irq_lock().\n */\nstatic inline void k_cpu_atomic_idle(unsigned int key)\n{\n\tarch_cpu_atomic_idle(key);\n}\n\n/**\n * @}\n */\n\n/**\n * @cond INTERNAL_HIDDEN\n * @internal\n */\n#ifdef ARCH_EXCEPT\n/* This architecture has direct support for triggering a CPU exception */\n#define z_except_reason(reason)\tARCH_EXCEPT(reason)\n#else\n\n#if !defined(CONFIG_ASSERT_NO_FILE_INFO)\n#define __EXCEPT_LOC() __ASSERT_PRINT(&quot;@ %s:%d\\n&quot;, __FILE__, __LINE__)\n#else\n#define __EXCEPT_LOC()\n#endif\n\n/* NOTE: This is the implementation for arches that do not implement\n * ARCH_EXCEPT() to generate a real CPU exception.\n *\n * We won&#x27;t have a real exception frame to determine the PC value when\n * the oops occurred, so print file and line number before we jump into\n * the fatal error handler.\n */\n#define z_except_reason(reason) do { \\\n\t\t__EXCEPT_LOC();              \\\n\t\tz_fatal_error(reason, NULL); \\\n\t} while (false)\n\n#endif /* _ARCH__EXCEPT */\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @brief Fatally terminate a thread\n *\n * This should be called when a thread has encountered an unrecoverable\n * runtime condition and needs to terminate. What this ultimately\n * means is determined by the _fatal_error_handler() implementation, which\n * will be called will reason code K_ERR_KERNEL_OOPS.\n *\n * If this is called from ISR context, the default system fatal error handler\n * will treat it as an unrecoverable system error, just like k_panic().\n */\n#define k_oops()\tz_except_reason(K_ERR_KERNEL_OOPS)\n\n/**\n * @brief Fatally terminate the system\n *\n * This should be called when the Zephyr kernel has encountered an\n * unrecoverable runtime condition and needs to terminate. What this ultimately\n * means is determined by the _fatal_error_handler() implementation, which\n * will be called will reason code K_ERR_KERNEL_PANIC.\n */\n#define k_panic()\tz_except_reason(K_ERR_KERNEL_PANIC)\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n/*\n * private APIs that are utilized by one or more public APIs\n */\n\n/**\n * @internal\n */\nvoid z_timer_expiration_handler(struct _timeout *timeout);\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n#ifdef CONFIG_PRINTK\n/**\n * @brief Emit a character buffer to the console device\n *\n * @param c String of characters to print\n * @param n The length of the string\n *\n */\n__syscall void k_str_out(char *c, size_t n);\n#endif\n\n/**\n * @defgroup float_apis Floating Point APIs\n * @ingroup kernel_apis\n * @{\n */\n\n/**\n * @brief Disable preservation of floating point context information.\n *\n * This routine informs the kernel that the specified thread\n * will no longer be using the floating point registers.\n *\n * @warning\n * Some architectures apply restrictions on how the disabling of floating\n * point preservation may be requested, see arch_float_disable.\n *\n * @warning\n * This routine should only be used to disable floating point support for\n * a thread that currently has such support enabled.\n *\n * @param thread ID of thread.\n *\n * @retval 0        On success.\n * @retval -ENOTSUP If the floating point disabling is not implemented.\n *         -EINVAL  If the floating point disabling could not be performed.\n */\n__syscall int k_float_disable(struct k_thread *thread);\n\n/**\n * @brief Enable preservation of floating point context information.\n *\n * This routine informs the kernel that the specified thread\n * will use the floating point registers.\n\n * Invoking this routine initializes the thread&#x27;s floating point context info\n * to that of an FPU that has been reset. The next time the thread is scheduled\n * by z_swap() it will either inherit an FPU that is guaranteed to be in a\n * &quot;sane&quot; state (if the most recent user of the FPU was cooperatively swapped\n * out) or the thread&#x27;s own floating point context will be loaded (if the most\n * recent user of the FPU was preempted, or if this thread is the first user\n * of the FPU). Thereafter, the kernel will protect the thread&#x27;s FP context\n * so that it is not altered during a preemptive context switch.\n *\n * The @a options parameter indicates which floating point register sets will\n * be used by the specified thread.\n *\n * For x86 options:\n *\n * - K_FP_REGS  indicates x87 FPU and MMX registers only\n * - K_SSE_REGS indicates SSE registers (and also x87 FPU and MMX registers)\n *\n * @warning\n * Some architectures apply restrictions on how the enabling of floating\n * point preservation may be requested, see arch_float_enable.\n *\n * @warning\n * This routine should only be used to enable floating point support for\n * a thread that currently has such support enabled.\n *\n * @param thread  ID of thread.\n * @param options architecture dependent options\n *\n * @retval 0        On success.\n * @retval -ENOTSUP If the floating point enabling is not implemented.\n *         -EINVAL  If the floating point enabling could not be performed.\n */\n__syscall int k_float_enable(struct k_thread *thread, unsigned int options);\n\n/**\n * @}\n */\n\n/**\n * @brief Get the runtime statistics of a thread\n *\n * @param thread ID of thread.\n * @param stats Pointer to struct to copy statistics into.\n * @return -EINVAL if null pointers, otherwise 0\n */\nint k_thread_runtime_stats_get(k_tid_t thread,\n\t\t\t       k_thread_runtime_stats_t *stats);\n\n/**\n * @brief Get the runtime statistics of all threads\n *\n * @param stats Pointer to struct to copy statistics into.\n * @return -EINVAL if null pointers, otherwise 0\n */\nint k_thread_runtime_stats_all_get(k_thread_runtime_stats_t *stats);\n\n/**\n * @brief Get the runtime statistics of all threads on specified cpu\n *\n * @param cpu The cpu number\n * @param stats Pointer to struct to copy statistics into.\n * @return -EINVAL if null pointers, otherwise 0\n */\nint k_thread_runtime_stats_cpu_get(int cpu, k_thread_runtime_stats_t *stats);\n\n/**\n * @brief Enable gathering of runtime statistics for specified thread\n *\n * This routine enables the gathering of runtime statistics for the specified\n * thread.\n *\n * @param thread ID of thread\n * @return -EINVAL if invalid thread ID, otherwise 0\n */\nint k_thread_runtime_stats_enable(k_tid_t thread);\n\n/**\n * @brief Disable gathering of runtime statistics for specified thread\n *\n * This routine disables the gathering of runtime statistics for the specified\n * thread.\n *\n * @param thread ID of thread\n * @return -EINVAL if invalid thread ID, otherwise 0\n */\nint k_thread_runtime_stats_disable(k_tid_t thread);\n\n/**\n * @brief Enable gathering of system runtime statistics\n *\n * This routine enables the gathering of system runtime statistics. Note that\n * it does not affect the gathering of similar statistics for individual\n * threads.\n */\nvoid k_sys_runtime_stats_enable(void);\n\n/**\n * @brief Disable gathering of system runtime statistics\n *\n * This routine disables the gathering of system runtime statistics. Note that\n * it does not affect the gathering of similar statistics for individual\n * threads.\n */\nvoid k_sys_runtime_stats_disable(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#include &lt;zephyr/tracing/tracing.h&gt;\n#include &lt;zephyr/syscalls/kernel.h&gt;\n\n#endif /* !_ASMLANGUAGE */\n\n#endif /* ZEPHYR_INCLUDE_KERNEL_H_ */\n"}, "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel/thread.h": {"id": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel/thread.h", "filePath": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel/thread.h", "content": "/*\n * Copyright (c) 2016, Wind River Systems, Inc.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef ZEPHYR_INCLUDE_KERNEL_THREAD_H_\n#define ZEPHYR_INCLUDE_KERNEL_THREAD_H_\n\n#ifdef CONFIG_DEMAND_PAGING_THREAD_STATS\n#include &lt;zephyr/kernel/mm/demand_paging.h&gt;\n#endif /* CONFIG_DEMAND_PAGING_THREAD_STATS */\n\n#include &lt;zephyr/kernel/stats.h&gt;\n#include &lt;zephyr/arch/arch_interface.h&gt;\n\n/**\n * @typedef k_thread_entry_t\n * @brief Thread entry point function type.\n *\n * A thread&#x27;s entry point function is invoked when the thread starts executing.\n * Up to 3 argument values can be passed to the function.\n *\n * The thread terminates execution permanently if the entry point function\n * returns. The thread is responsible for releasing any shared resources\n * it may own (such as mutexes and dynamically allocated memory), prior to\n * returning.\n *\n * @param p1 First argument.\n * @param p2 Second argument.\n * @param p3 Third argument.\n */\n\n#ifdef CONFIG_THREAD_MONITOR\nstruct __thread_entry {\n\tk_thread_entry_t pEntry;\n\tvoid *parameter1;\n\tvoid *parameter2;\n\tvoid *parameter3;\n};\n#endif /* CONFIG_THREAD_MONITOR */\n\nstruct k_thread;\n\n/*\n * This _pipe_desc structure is used by the pipes kernel module when\n * CONFIG_PIPES has been selected.\n */\n\nstruct _pipe_desc {\n\tsys_dnode_t      node;\n\tunsigned char   *buffer;         /* Position in src/dest buffer */\n\tsize_t           bytes_to_xfer;  /* # bytes left to transfer */\n\tstruct k_thread *thread;         /* Back pointer to pended thread */\n};\n\n/* can be used for creating &#x27;dummy&#x27; threads, e.g. for pending on objects */\nstruct _thread_base {\n\n\t/* this thread&#x27;s entry in a ready/wait queue */\n\tunion {\n\t\tsys_dnode_t qnode_dlist;\n\t\tstruct rbnode qnode_rb;\n\t};\n\n\t/* wait queue on which the thread is pended (needed only for\n\t * trees, not dumb lists)\n\t */\n\t_wait_q_t *pended_on;\n\n\t/* user facing &#x27;thread options&#x27;; values defined in include/kernel.h */\n\tuint8_t user_options;\n\n\t/* thread state */\n\tuint8_t thread_state;\n\n\t/*\n\t * scheduler lock count and thread priority\n\t *\n\t * These two fields control the preemptibility of a thread.\n\t *\n\t * When the scheduler is locked, sched_locked is decremented, which\n\t * means that the scheduler is locked for values from 0xff to 0x01. A\n\t * thread is coop if its prio is negative, thus 0x80 to 0xff when\n\t * looked at the value as unsigned.\n\t *\n\t * By putting them end-to-end, this means that a thread is\n\t * non-preemptible if the bundled value is greater than or equal to\n\t * 0x0080.\n\t */\n\tunion {\n\t\tstruct {\n#ifdef CONFIG_BIG_ENDIAN\n\t\t\tuint8_t sched_locked;\n\t\t\tint8_t prio;\n#else /* Little Endian */\n\t\t\tint8_t prio;\n\t\t\tuint8_t sched_locked;\n#endif /* CONFIG_BIG_ENDIAN */\n\t\t};\n\t\tuint16_t preempt;\n\t};\n\n#ifdef CONFIG_SCHED_DEADLINE\n\tint prio_deadline;\n#endif /* CONFIG_SCHED_DEADLINE */\n\n\tuint32_t order_key;\n\n#ifdef CONFIG_SMP\n\t/* True for the per-CPU idle threads */\n\tuint8_t is_idle;\n\n\t/* CPU index on which thread was last run */\n\tuint8_t cpu;\n\n\t/* Recursive count of irq_lock() calls */\n\tuint8_t global_lock_count;\n\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_SCHED_CPU_MASK\n\t/* &quot;May run on&quot; bits for each CPU */\n#if CONFIG_MP_MAX_NUM_CPUS &lt;= 8\n\tuint8_t cpu_mask;\n#else\n\tuint16_t cpu_mask;\n#endif /* CONFIG_MP_MAX_NUM_CPUS */\n#endif /* CONFIG_SCHED_CPU_MASK */\n\n\t/* data returned by APIs */\n\tvoid *swap_data;\n\n#ifdef CONFIG_SYS_CLOCK_EXISTS\n\t/* this thread&#x27;s entry in a timeout queue */\n\tstruct _timeout timeout;\n#endif /* CONFIG_SYS_CLOCK_EXISTS */\n\n#ifdef CONFIG_TIMESLICE_PER_THREAD\n\tint32_t slice_ticks;\n\tk_thread_timeslice_fn_t slice_expired;\n\tvoid *slice_data;\n#endif /* CONFIG_TIMESLICE_PER_THREAD */\n\n#ifdef CONFIG_SCHED_THREAD_USAGE\n\tstruct k_cycle_stats  usage;   /* Track thread usage statistics */\n#endif /* CONFIG_SCHED_THREAD_USAGE */\n};\n\ntypedef struct _thread_base _thread_base_t;\n\n#if defined(CONFIG_THREAD_STACK_INFO)\n/* Contains the stack information of a thread */\nstruct _thread_stack_info {\n\t/* Stack start - Represents the start address of the thread-writable\n\t * stack area.\n\t */\n\tuintptr_t start;\n\n\t/* Thread writable stack buffer size. Represents the size of the actual\n\t * buffer, starting from the &#x27;start&#x27; member, that should be writable by\n\t * the thread. This comprises of the thread stack area, any area reserved\n\t * for local thread data storage, as well as any area left-out due to\n\t * random adjustments applied to the initial thread stack pointer during\n\t * thread initialization.\n\t */\n\tsize_t size;\n\n\t/* Adjustment value to the size member, removing any storage\n\t * used for TLS or random stack base offsets. (start + size - delta)\n\t * is the initial stack pointer for a thread. May be 0.\n\t */\n\tsize_t delta;\n\n#if defined(CONFIG_THREAD_STACK_MEM_MAPPED)\n\tstruct {\n\t\t/** Base address of the memory mapped thread stack */\n\t\tk_thread_stack_t *addr;\n\n\t\t/** Size of whole mapped stack object */\n\t\tsize_t sz;\n\t} mapped;\n#endif /* CONFIG_THREAD_STACK_MEM_MAPPED */\n};\n\ntypedef struct _thread_stack_info _thread_stack_info_t;\n#endif /* CONFIG_THREAD_STACK_INFO */\n\n#if defined(CONFIG_USERSPACE)\nstruct _mem_domain_info {\n\t/** memory domain queue node */\n\tsys_dnode_t mem_domain_q_node;\n\t/** memory domain of the thread */\n\tstruct k_mem_domain *mem_domain;\n};\n\n#endif /* CONFIG_USERSPACE */\n\n#ifdef CONFIG_THREAD_USERSPACE_LOCAL_DATA\nstruct _thread_userspace_local_data {\n#if defined(CONFIG_ERRNO) &amp;&amp; !defined(CONFIG_ERRNO_IN_TLS) &amp;&amp; !defined(CONFIG_LIBC_ERRNO)\n\tint errno_var;\n#endif /* CONFIG_ERRNO &amp;&amp; !CONFIG_ERRNO_IN_TLS &amp;&amp; !CONFIG_LIBC_ERRNO */\n};\n#endif /* CONFIG_THREAD_USERSPACE_LOCAL_DATA */\n\ntypedef struct k_thread_runtime_stats {\n#ifdef CONFIG_SCHED_THREAD_USAGE\n\t/*\n\t * For CPU stats, execution_cycles is the sum of non-idle + idle cycles.\n\t * For thread stats, execution_cycles = total_cycles.\n\t */\n\tuint64_t execution_cycles;    /* total # of cycles (cpu: non-idle + idle) */\n\tuint64_t total_cycles;        /* total # of non-idle cycles */\n#endif /* CONFIG_SCHED_THREAD_USAGE */\n\n#ifdef CONFIG_SCHED_THREAD_USAGE_ANALYSIS\n\t/*\n\t * For threads, the following fields refer to the time spent executing\n\t * as bounded by when the thread was scheduled in and scheduled out.\n\t * For CPUs, the same fields refer to the time spent executing\n\t * non-idle threads as bounded by the idle thread(s).\n\t */\n\n\tuint64_t current_cycles;      /* current # of non-idle cycles */\n\tuint64_t peak_cycles;         /* peak # of non-idle cycles */\n\tuint64_t average_cycles;      /* average # of non-idle cycles */\n#endif /* CONFIG_SCHED_THREAD_USAGE_ANALYSIS */\n\n#ifdef CONFIG_SCHED_THREAD_USAGE_ALL\n\t/*\n\t * This field is always zero for individual threads. It only comes\n\t * into play when gathering statistics for the CPU. In that case it\n\t * represents the total number of cycles spent idling.\n\t */\n\n\tuint64_t idle_cycles;\n#endif /* CONFIG_SCHED_THREAD_USAGE_ALL */\n\n#if defined(__cplusplus) &amp;&amp; !defined(CONFIG_SCHED_THREAD_USAGE) &amp;&amp;                                 \\\n\t!defined(CONFIG_SCHED_THREAD_USAGE_ANALYSIS) &amp;&amp; !defined(CONFIG_SCHED_THREAD_USAGE_ALL)\n\t/* If none of the above Kconfig values are defined, this struct will have a size 0 in C\n\t * which is not allowed in C++ (it&#x27;ll have a size 1). To prevent this, we add a 1 byte dummy\n\t * variable when the struct would otherwise be empty.\n\t */\n\tuint8_t dummy;\n#endif\n}  k_thread_runtime_stats_t;\n\nstruct z_poller {\n\tbool is_polling;\n\tuint8_t mode;\n};\n\n/**\n * @ingroup thread_apis\n * Thread Structure\n */\nstruct k_thread {\n\n\tstruct _thread_base base;\n\n\t/** defined by the architecture, but all archs need these */\n\tstruct _callee_saved callee_saved;\n\n\t/** static thread init data */\n\tvoid *init_data;\n\n\t/** threads waiting in k_thread_join() */\n\t_wait_q_t join_queue;\n\n#if defined(CONFIG_POLL)\n\tstruct z_poller poller;\n#endif /* CONFIG_POLL */\n\n#if defined(CONFIG_EVENTS)\n\tstruct k_thread *next_event_link;\n\n\tuint32_t   events;\n\tuint32_t   event_options;\n\n\t/** true if timeout should not wake the thread */\n\tbool no_wake_on_timeout;\n#endif /* CONFIG_EVENTS */\n\n#if defined(CONFIG_THREAD_MONITOR)\n\t/** thread entry and parameters description */\n\tstruct __thread_entry entry;\n\n\t/** next item in list of all threads */\n\tstruct k_thread *next_thread;\n#endif /* CONFIG_THREAD_MONITOR */\n\n#if defined(CONFIG_THREAD_NAME)\n\t/** Thread name */\n\tchar name[CONFIG_THREAD_MAX_NAME_LEN];\n#endif /* CONFIG_THREAD_NAME */\n\n#ifdef CONFIG_THREAD_CUSTOM_DATA\n\t/** crude thread-local storage */\n\tvoid *custom_data;\n#endif /* CONFIG_THREAD_CUSTOM_DATA */\n\n#ifdef CONFIG_THREAD_USERSPACE_LOCAL_DATA\n\tstruct _thread_userspace_local_data *userspace_local_data;\n#endif /* CONFIG_THREAD_USERSPACE_LOCAL_DATA */\n\n#if defined(CONFIG_ERRNO) &amp;&amp; !defined(CONFIG_ERRNO_IN_TLS) &amp;&amp; !defined(CONFIG_LIBC_ERRNO)\n#ifndef CONFIG_USERSPACE\n\t/** per-thread errno variable */\n\tint errno_var;\n#endif /* CONFIG_USERSPACE */\n#endif /* CONFIG_ERRNO &amp;&amp; !CONFIG_ERRNO_IN_TLS &amp;&amp; !CONFIG_LIBC_ERRNO */\n\n#if defined(CONFIG_THREAD_STACK_INFO)\n\t/** Stack Info */\n\tstruct _thread_stack_info stack_info;\n#endif /* CONFIG_THREAD_STACK_INFO */\n\n#if defined(CONFIG_USERSPACE)\n\t/** memory domain info of the thread */\n\tstruct _mem_domain_info mem_domain_info;\n\n\t/**\n\t * Base address of thread stack.\n\t *\n\t * If memory mapped stack (CONFIG_THREAD_STACK_MEM_MAPPED)\n\t * is enabled, this is the physical address of the stack.\n\t */\n\tk_thread_stack_t *stack_obj;\n\n\t/** current syscall frame pointer */\n\tvoid *syscall_frame;\n#endif /* CONFIG_USERSPACE */\n\n\n#if defined(CONFIG_USE_SWITCH)\n\t/* When using __switch() a few previously arch-specific items\n\t * become part of the core OS\n\t */\n\n\t/** z_swap() return value */\n\tint swap_retval;\n\n\t/** Context handle returned via arch_switch() */\n\tvoid *switch_handle;\n#endif /* CONFIG_USE_SWITCH */\n\t/** resource pool */\n\tstruct k_heap *resource_pool;\n\n#if defined(CONFIG_THREAD_LOCAL_STORAGE)\n\t/* Pointer to arch-specific TLS area */\n\tuintptr_t tls;\n#endif /* CONFIG_THREAD_LOCAL_STORAGE */\n\n#ifdef CONFIG_DEMAND_PAGING_THREAD_STATS\n\t/** Paging statistics */\n\tstruct k_mem_paging_stats_t paging_stats;\n#endif /* CONFIG_DEMAND_PAGING_THREAD_STATS */\n\n#ifdef CONFIG_PIPES\n\t/** Pipe descriptor used with blocking k_pipe operations */\n\tstruct _pipe_desc pipe_desc;\n#endif /* CONFIG_PIPES */\n\n#ifdef CONFIG_OBJ_CORE_THREAD\n\tstruct k_obj_core  obj_core;\n#endif /* CONFIG_OBJ_CORE_THREAD */\n\n#ifdef CONFIG_SMP\n\t/** threads waiting in k_thread_suspend() */\n\t_wait_q_t  halt_queue;\n#endif /* CONFIG_SMP */\n\n\t/** arch-specifics: must always be at the end */\n\tstruct _thread_arch arch;\n};\n\ntypedef struct k_thread _thread_t;\ntypedef struct k_thread *k_tid_t;\n\n#endif /* ZEPHYR_INCLUDE_KERNEL_THREAD_H_ */\n"}}, "reports": [{"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "47ec898af5f13763925c5379b8e49140", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 18, "column": 1, "message": "unused parameter 'dev'", "events": [{"message": "expanded from macro 'DT_DEFINE_ACTION_FUNCTION'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 16, "column": 53}, {"message": "unused parameter 'dev'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 18, "column": 1}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "4a6308f1814085ec37efc3b12dd57ac0", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 19, "column": 1, "message": "unused parameter 'dev'", "events": [{"message": "expanded from macro 'DT_DEFINE_ACTION_FUNCTION'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 16, "column": 53}, {"message": "unused parameter 'dev'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 19, "column": 1}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "4e69bf9a58ec0034f9561047bf383e01", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 20, "column": 1, "message": "unused parameter 'dev'", "events": [{"message": "expanded from macro 'DT_DEFINE_ACTION_FUNCTION'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 16, "column": 53}, {"message": "unused parameter 'dev'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 20, "column": 1}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "8fd8a3b696dd65b3bf531b91c5bbc45d", "checker": {"name": "clang-diagnostic-unused-function", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-function"}, "analyzerName": "clang-tidy", "line": 20, "column": 41, "message": "unused function 'on_shutdown'", "events": [{"message": "unused function 'on_shutdown'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 20, "column": 41}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "89197a675b030559a66ca0e1132d1cc9", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 22, "column": 27, "message": "unused parameter 'arg1'", "events": [{"message": "unused parameter 'arg1'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 22, "column": 27}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "7c1c32db2f06cb30c84b43c00cb33443", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 22, "column": 39, "message": "unused parameter 'arg2'", "events": [{"message": "unused parameter 'arg2'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 22, "column": 39}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "bfb68e10cae7794963eb622511240a02", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 22, "column": 51, "message": "unused parameter 'arg3'", "events": [{"message": "unused parameter 'arg3'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 22, "column": 51}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "0b6f550809e8feadee8cdc6e8687ca8e", "checker": {"name": "bugprone-branch-clone", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/branch-clone.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 1, "message": "conditional operator with identical true and false expressions", "events": [{"message": "expanded from macro 'K_THREAD_DEFINE'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel.h", "line": 835, "column": 2}, {"message": "expanded from macro 'Z_THREAD_COMMON_DEFINE'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel.h", "line": 790, "column": 3}, {"message": "expanded from macro 'Z_THREAD_INITIALIZER'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel.h", "line": 777, "column": 2}, {"message": "conditional operator with identical true and false expressions", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 33, "column": 1}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}, {"fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "reportHash": "401cfd6596c6c1ac1918c6de8d749057", "checker": {"name": "misc-misplaced-const", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/misplaced-const.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 17, "message": "'esphome_tid' declared with a const-qualified typedef; results in the type being 'struct k_thread *const' instead of 'const struct k_thread *'", "events": [{"message": "typedef declared here", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/zephyr/include/zephyr/kernel/thread.h", "line": 380, "column": 26}, {"message": "'esphome_tid' declared with a const-qualified typedef; results in the type being 'struct k_thread *const' instead of 'const struct k_thread *'", "fileId": "/home/runner/work/zephyr_esphome/zephyr_esphome/esphome/subsys/net/lib/esphome/components/esphome.c", "line": 33, "column": 17}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
